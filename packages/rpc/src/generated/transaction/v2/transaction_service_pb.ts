// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file transaction/v2/transaction_service.proto (package code.transaction.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { AccountType, Blockhash, DeviceToken, Hash, IntentId, Relationship, Signature, SolanaAccountId, Transaction } from "../../common/v1/model_pb";

/**
 * @generated from enum code.transaction.v2.AirdropType
 */
export enum AirdropType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Reward for giving someone else their first Kin
   *
   * @generated from enum value: GIVE_FIRST_KIN = 1;
   */
  GIVE_FIRST_KIN = 1,

  /**
   * Airdrop for getting a user started with first Kin balance
   *
   * @generated from enum value: GET_FIRST_KIN = 2;
   */
  GET_FIRST_KIN = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AirdropType)
proto3.util.setEnumType(AirdropType, "code.transaction.v2.AirdropType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "GIVE_FIRST_KIN" },
  { no: 2, name: "GET_FIRST_KIN" },
]);

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest
 */
export class SubmitIntentRequest extends Message<SubmitIntentRequest> {
  /**
   * @generated from oneof code.transaction.v2.SubmitIntentRequest.request
   */
  request: {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentRequest.SubmitActions submit_actions = 1;
     */
    value: SubmitIntentRequest_SubmitActions;
    case: "submitActions";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentRequest.SubmitSignatures submit_signatures = 2;
     */
    value: SubmitIntentRequest_SubmitSignatures;
    case: "submitSignatures";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SubmitIntentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "submit_actions", kind: "message", T: SubmitIntentRequest_SubmitActions, oneof: "request" },
    { no: 2, name: "submit_signatures", kind: "message", T: SubmitIntentRequest_SubmitSignatures, oneof: "request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest | PlainMessage<SubmitIntentRequest> | undefined, b: SubmitIntentRequest | PlainMessage<SubmitIntentRequest> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest.SubmitActions
 */
export class SubmitIntentRequest_SubmitActions extends Message<SubmitIntentRequest_SubmitActions> {
  /**
   * The globally unique client generated intent ID. Use the original intent
   * ID when operating on actions that mutate the intent.
   *
   * @generated from field: code.common.v1.IntentId id = 1;
   */
  id?: IntentId;

  /**
   * The verified owner account public key
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * Additional metadata that describes the high-level intention
   *
   * @generated from field: code.transaction.v2.Metadata metadata = 3;
   */
  metadata?: Metadata;

  /**
   * The set of all ordered actions required to fulfill the intent
   *
   * @generated from field: repeated code.transaction.v2.Action actions = 4;
   */
  actions: Action[] = [];

  /**
   * The signature is of serialize(SubmitActions) without this field set using the
   * private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  /**
   * Device token for antispam measures against fake devices
   *
   * @generated from field: code.common.v1.DeviceToken device_token = 6;
   */
  deviceToken?: DeviceToken;

  constructor(data?: PartialMessage<SubmitIntentRequest_SubmitActions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest.SubmitActions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: IntentId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "metadata", kind: "message", T: Metadata },
    { no: 4, name: "actions", kind: "message", T: Action, repeated: true },
    { no: 5, name: "signature", kind: "message", T: Signature },
    { no: 6, name: "device_token", kind: "message", T: DeviceToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest_SubmitActions | PlainMessage<SubmitIntentRequest_SubmitActions> | undefined, b: SubmitIntentRequest_SubmitActions | PlainMessage<SubmitIntentRequest_SubmitActions> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest_SubmitActions, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest.SubmitSignatures
 */
export class SubmitIntentRequest_SubmitSignatures extends Message<SubmitIntentRequest_SubmitSignatures> {
  /**
   * The set of all signatures for each transaction requiring signature from the
   * authority accounts.
   *
   * @generated from field: repeated code.common.v1.Signature signatures = 1;
   */
  signatures: Signature[] = [];

  constructor(data?: PartialMessage<SubmitIntentRequest_SubmitSignatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest.SubmitSignatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signatures", kind: "message", T: Signature, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest_SubmitSignatures | PlainMessage<SubmitIntentRequest_SubmitSignatures> | undefined, b: SubmitIntentRequest_SubmitSignatures | PlainMessage<SubmitIntentRequest_SubmitSignatures> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest_SubmitSignatures, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse
 */
export class SubmitIntentResponse extends Message<SubmitIntentResponse> {
  /**
   * @generated from oneof code.transaction.v2.SubmitIntentResponse.response
   */
  response: {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.ServerParameters server_parameters = 1;
     */
    value: SubmitIntentResponse_ServerParameters;
    case: "serverParameters";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.Success success = 2;
     */
    value: SubmitIntentResponse_Success;
    case: "success";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.Error error = 3;
     */
    value: SubmitIntentResponse_Error;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SubmitIntentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: SubmitIntentResponse_ServerParameters, oneof: "response" },
    { no: 2, name: "success", kind: "message", T: SubmitIntentResponse_Success, oneof: "response" },
    { no: 3, name: "error", kind: "message", T: SubmitIntentResponse_Error, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse | PlainMessage<SubmitIntentResponse> | undefined, b: SubmitIntentResponse | PlainMessage<SubmitIntentResponse> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.ServerParameters
 */
export class SubmitIntentResponse_ServerParameters extends Message<SubmitIntentResponse_ServerParameters> {
  /**
   * The set of all server paremeters required to fill missing transaction
   * details. Server guarantees to provide a message for each client action
   * in an order consistent with the received action list. 
   *
   * @generated from field: repeated code.transaction.v2.ServerParameter server_parameters = 1;
   */
  serverParameters: ServerParameter[] = [];

  constructor(data?: PartialMessage<SubmitIntentResponse_ServerParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.ServerParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: ServerParameter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_ServerParameters | PlainMessage<SubmitIntentResponse_ServerParameters> | undefined, b: SubmitIntentResponse_ServerParameters | PlainMessage<SubmitIntentResponse_ServerParameters> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_ServerParameters, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.Success
 */
export class SubmitIntentResponse_Success extends Message<SubmitIntentResponse_Success> {
  /**
   * @generated from field: code.transaction.v2.SubmitIntentResponse.Success.Code code = 1;
   */
  code = SubmitIntentResponse_Success_Code.OK;

  constructor(data?: PartialMessage<SubmitIntentResponse_Success>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.Success";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SubmitIntentResponse_Success_Code) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_Success | PlainMessage<SubmitIntentResponse_Success> | undefined, b: SubmitIntentResponse_Success | PlainMessage<SubmitIntentResponse_Success> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_Success, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SubmitIntentResponse.Success.Code
 */
export enum SubmitIntentResponse_Success_Code {
  /**
   * The intent was successfully created and is now scheduled.
   *
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(SubmitIntentResponse_Success_Code)
proto3.util.setEnumType(SubmitIntentResponse_Success_Code, "code.transaction.v2.SubmitIntentResponse.Success.Code", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.Error
 */
export class SubmitIntentResponse_Error extends Message<SubmitIntentResponse_Error> {
  /**
   * @generated from field: code.transaction.v2.SubmitIntentResponse.Error.Code code = 1;
   */
  code = SubmitIntentResponse_Error_Code.DENIED;

  /**
   * @generated from field: repeated code.transaction.v2.ErrorDetails error_details = 2;
   */
  errorDetails: ErrorDetails[] = [];

  constructor(data?: PartialMessage<SubmitIntentResponse_Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SubmitIntentResponse_Error_Code) },
    { no: 2, name: "error_details", kind: "message", T: ErrorDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_Error | PlainMessage<SubmitIntentResponse_Error> | undefined, b: SubmitIntentResponse_Error | PlainMessage<SubmitIntentResponse_Error> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_Error, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SubmitIntentResponse.Error.Code
 */
export enum SubmitIntentResponse_Error_Code {
  /**
   * Denied by a guard (spam, money laundering, etc)
   *
   * @generated from enum value: DENIED = 0;
   */
  DENIED = 0,

  /**
   * The intent is invalid.
   *
   * @generated from enum value: INVALID_INTENT = 1;
   */
  INVALID_INTENT = 1,

  /**
   * There is an issue with provided signatures.
   *
   * @generated from enum value: SIGNATURE_ERROR = 2;
   */
  SIGNATURE_ERROR = 2,

  /**
   * Server detected client has stale state.
   *
   * @generated from enum value: STALE_STATE = 3;
   */
  STALE_STATE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SubmitIntentResponse_Error_Code)
proto3.util.setEnumType(SubmitIntentResponse_Error_Code, "code.transaction.v2.SubmitIntentResponse.Error.Code", [
  { no: 0, name: "DENIED" },
  { no: 1, name: "INVALID_INTENT" },
  { no: 2, name: "SIGNATURE_ERROR" },
  { no: 3, name: "STALE_STATE" },
]);

/**
 * @generated from message code.transaction.v2.GetIntentMetadataRequest
 */
export class GetIntentMetadataRequest extends Message<GetIntentMetadataRequest> {
  /**
   * The intent ID to query
   *
   * @generated from field: code.common.v1.IntentId intent_id = 1;
   */
  intentId?: IntentId;

  /**
   * The verified owner account public key when not signing with the rendezvous
   * key. Only owner accounts involved in the intent can access the metadata.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(GetIntentStatusRequest) without this field set
   * using the private key of the rendezvous or owner account. This provides an
   * authentication mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetIntentMetadataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetIntentMetadataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "intent_id", kind: "message", T: IntentId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntentMetadataRequest | PlainMessage<GetIntentMetadataRequest> | undefined, b: GetIntentMetadataRequest | PlainMessage<GetIntentMetadataRequest> | undefined): boolean {
    return proto3.util.equals(GetIntentMetadataRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetIntentMetadataResponse
 */
export class GetIntentMetadataResponse extends Message<GetIntentMetadataResponse> {
  /**
   * @generated from field: code.transaction.v2.GetIntentMetadataResponse.Result result = 1;
   */
  result = GetIntentMetadataResponse_Result.OK;

  /**
   * @generated from field: code.transaction.v2.Metadata metadata = 2;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<GetIntentMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetIntentMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetIntentMetadataResponse_Result) },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntentMetadataResponse | PlainMessage<GetIntentMetadataResponse> | undefined, b: GetIntentMetadataResponse | PlainMessage<GetIntentMetadataResponse> | undefined): boolean {
    return proto3.util.equals(GetIntentMetadataResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetIntentMetadataResponse.Result
 */
export enum GetIntentMetadataResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetIntentMetadataResponse_Result)
proto3.util.setEnumType(GetIntentMetadataResponse_Result, "code.transaction.v2.GetIntentMetadataResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.transaction.v2.GetPrivacyUpgradeStatusRequest
 */
export class GetPrivacyUpgradeStatusRequest extends Message<GetPrivacyUpgradeStatusRequest> {
  /**
   * The intent ID
   *
   * @generated from field: code.common.v1.IntentId intent_id = 1;
   */
  intentId?: IntentId;

  /**
   * The action ID for private transaction
   *
   * @generated from field: uint32 action_id = 2;
   */
  actionId = 0;

  constructor(data?: PartialMessage<GetPrivacyUpgradeStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetPrivacyUpgradeStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "intent_id", kind: "message", T: IntentId },
    { no: 2, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPrivacyUpgradeStatusRequest {
    return new GetPrivacyUpgradeStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPrivacyUpgradeStatusRequest {
    return new GetPrivacyUpgradeStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPrivacyUpgradeStatusRequest {
    return new GetPrivacyUpgradeStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetPrivacyUpgradeStatusRequest | PlainMessage<GetPrivacyUpgradeStatusRequest> | undefined, b: GetPrivacyUpgradeStatusRequest | PlainMessage<GetPrivacyUpgradeStatusRequest> | undefined): boolean {
    return proto3.util.equals(GetPrivacyUpgradeStatusRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetPrivacyUpgradeStatusResponse
 */
export class GetPrivacyUpgradeStatusResponse extends Message<GetPrivacyUpgradeStatusResponse> {
  /**
   * @generated from field: code.transaction.v2.GetPrivacyUpgradeStatusResponse.Result result = 1;
   */
  result = GetPrivacyUpgradeStatusResponse_Result.OK;

  /**
   * @generated from field: code.transaction.v2.GetPrivacyUpgradeStatusResponse.Status status = 2;
   */
  status = GetPrivacyUpgradeStatusResponse_Status.UNKNOWN;

  constructor(data?: PartialMessage<GetPrivacyUpgradeStatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetPrivacyUpgradeStatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetPrivacyUpgradeStatusResponse_Result) },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(GetPrivacyUpgradeStatusResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPrivacyUpgradeStatusResponse {
    return new GetPrivacyUpgradeStatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPrivacyUpgradeStatusResponse {
    return new GetPrivacyUpgradeStatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPrivacyUpgradeStatusResponse {
    return new GetPrivacyUpgradeStatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetPrivacyUpgradeStatusResponse | PlainMessage<GetPrivacyUpgradeStatusResponse> | undefined, b: GetPrivacyUpgradeStatusResponse | PlainMessage<GetPrivacyUpgradeStatusResponse> | undefined): boolean {
    return proto3.util.equals(GetPrivacyUpgradeStatusResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetPrivacyUpgradeStatusResponse.Result
 */
export enum GetPrivacyUpgradeStatusResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The provided intent ID doesn't exist
   *
   * @generated from enum value: INTENT_NOT_FOUND = 1;
   */
  INTENT_NOT_FOUND = 1,

  /**
   * The provided action ID doesn't exist
   *
   * @generated from enum value: ACTION_NOT_FOUND = 2;
   */
  ACTION_NOT_FOUND = 2,

  /**
   * The provided action doesn't map to a private transaction
   *
   * @generated from enum value: INVALID_ACTION = 3;
   */
  INVALID_ACTION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(GetPrivacyUpgradeStatusResponse_Result)
proto3.util.setEnumType(GetPrivacyUpgradeStatusResponse_Result, "code.transaction.v2.GetPrivacyUpgradeStatusResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "INTENT_NOT_FOUND" },
  { no: 2, name: "ACTION_NOT_FOUND" },
  { no: 3, name: "INVALID_ACTION" },
]);

/**
 * @generated from enum code.transaction.v2.GetPrivacyUpgradeStatusResponse.Status
 */
export enum GetPrivacyUpgradeStatusResponse_Status {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * The transaction for the temporary private transaction was submitted and
   * finalized. The opportunity to upgrade was missed.
   *
   * @generated from enum value: TEMPORARY_TRANSACTION_FINALIZED = 1;
   */
  TEMPORARY_TRANSACTION_FINALIZED = 1,

  /**
   * The next block of transactions hasn't been created. Wait and try again
   * later.
   *
   * @generated from enum value: WAITING_FOR_NEXT_BLOCK = 2;
   */
  WAITING_FOR_NEXT_BLOCK = 2,

  /**
   * The transaction can be upgraded to permanent privacy
   *
   * @generated from enum value: READY_FOR_UPGRADE = 3;
   */
  READY_FOR_UPGRADE = 3,

  /**
   * The transaction has already been upgraded
   *
   * @generated from enum value: ALREADY_UPGRADED = 4;
   */
  ALREADY_UPGRADED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(GetPrivacyUpgradeStatusResponse_Status)
proto3.util.setEnumType(GetPrivacyUpgradeStatusResponse_Status, "code.transaction.v2.GetPrivacyUpgradeStatusResponse.Status", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "TEMPORARY_TRANSACTION_FINALIZED" },
  { no: 2, name: "WAITING_FOR_NEXT_BLOCK" },
  { no: 3, name: "READY_FOR_UPGRADE" },
  { no: 4, name: "ALREADY_UPGRADED" },
]);

/**
 * @generated from message code.transaction.v2.GetPrioritizedIntentsForPrivacyUpgradeRequest
 */
export class GetPrioritizedIntentsForPrivacyUpgradeRequest extends Message<GetPrioritizedIntentsForPrivacyUpgradeRequest> {
  /**
   * The owner account to query against for upgradeable intents.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The maximum number of intents to return in the response. Default is 10.
   *
   * @generated from field: uint32 limit = 2;
   */
  limit = 0;

  /**
   * The signature is of serialize(GetPrioritizedIntentsForPrivacyUpgradeRequest)
   * without this field set using the private key of the owner account. This
   * provides an authentication mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetPrioritizedIntentsForPrivacyUpgradeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetPrioritizedIntentsForPrivacyUpgradeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPrioritizedIntentsForPrivacyUpgradeRequest {
    return new GetPrioritizedIntentsForPrivacyUpgradeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPrioritizedIntentsForPrivacyUpgradeRequest {
    return new GetPrioritizedIntentsForPrivacyUpgradeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPrioritizedIntentsForPrivacyUpgradeRequest {
    return new GetPrioritizedIntentsForPrivacyUpgradeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetPrioritizedIntentsForPrivacyUpgradeRequest | PlainMessage<GetPrioritizedIntentsForPrivacyUpgradeRequest> | undefined, b: GetPrioritizedIntentsForPrivacyUpgradeRequest | PlainMessage<GetPrioritizedIntentsForPrivacyUpgradeRequest> | undefined): boolean {
    return proto3.util.equals(GetPrioritizedIntentsForPrivacyUpgradeRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetPrioritizedIntentsForPrivacyUpgradeResponse
 */
export class GetPrioritizedIntentsForPrivacyUpgradeResponse extends Message<GetPrioritizedIntentsForPrivacyUpgradeResponse> {
  /**
   * @generated from field: code.transaction.v2.GetPrioritizedIntentsForPrivacyUpgradeResponse.Result result = 1;
   */
  result = GetPrioritizedIntentsForPrivacyUpgradeResponse_Result.OK;

  /**
   * Ordered from highest to lowest priority
   *
   * @generated from field: repeated code.transaction.v2.UpgradeableIntent items = 2;
   */
  items: UpgradeableIntent[] = [];

  constructor(data?: PartialMessage<GetPrioritizedIntentsForPrivacyUpgradeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetPrioritizedIntentsForPrivacyUpgradeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetPrioritizedIntentsForPrivacyUpgradeResponse_Result) },
    { no: 2, name: "items", kind: "message", T: UpgradeableIntent, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPrioritizedIntentsForPrivacyUpgradeResponse {
    return new GetPrioritizedIntentsForPrivacyUpgradeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPrioritizedIntentsForPrivacyUpgradeResponse {
    return new GetPrioritizedIntentsForPrivacyUpgradeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPrioritizedIntentsForPrivacyUpgradeResponse {
    return new GetPrioritizedIntentsForPrivacyUpgradeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetPrioritizedIntentsForPrivacyUpgradeResponse | PlainMessage<GetPrioritizedIntentsForPrivacyUpgradeResponse> | undefined, b: GetPrioritizedIntentsForPrivacyUpgradeResponse | PlainMessage<GetPrioritizedIntentsForPrivacyUpgradeResponse> | undefined): boolean {
    return proto3.util.equals(GetPrioritizedIntentsForPrivacyUpgradeResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetPrioritizedIntentsForPrivacyUpgradeResponse.Result
 */
export enum GetPrioritizedIntentsForPrivacyUpgradeResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetPrioritizedIntentsForPrivacyUpgradeResponse_Result)
proto3.util.setEnumType(GetPrioritizedIntentsForPrivacyUpgradeResponse_Result, "code.transaction.v2.GetPrioritizedIntentsForPrivacyUpgradeResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.transaction.v2.GetLimitsRequest
 */
export class GetLimitsRequest extends Message<GetLimitsRequest> {
  /**
   * The owner account whose limits will be calculated. Any other owner accounts
   * linked with the same identity of the owner will also be applied.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(GetLimitsRequest) without this field set
   * using the private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * All transactions starting at this time will be incorporated into the consumed
   * limit calculation. Clients should set this to the start of the current day in
   * the client's current time zone (because server has no knowledge of this atm).
   *
   * @generated from field: google.protobuf.Timestamp consumed_since = 3;
   */
  consumedSince?: Timestamp;

  constructor(data?: PartialMessage<GetLimitsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetLimitsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "consumed_since", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLimitsRequest | PlainMessage<GetLimitsRequest> | undefined, b: GetLimitsRequest | PlainMessage<GetLimitsRequest> | undefined): boolean {
    return proto3.util.equals(GetLimitsRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetLimitsResponse
 */
export class GetLimitsResponse extends Message<GetLimitsResponse> {
  /**
   * @generated from field: code.transaction.v2.GetLimitsResponse.Result result = 1;
   */
  result = GetLimitsResponse_Result.OK;

  /**
   * Remaining send limits keyed by currency
   *
   * @generated from field: map<string, code.transaction.v2.RemainingSendLimit> remaining_send_limits_by_currency = 2;
   */
  remainingSendLimitsByCurrency: { [key: string]: RemainingSendLimit } = {};

  /**
   * Deposit limits
   *
   * @generated from field: code.transaction.v2.DepositLimit deposit_limit = 3;
   */
  depositLimit?: DepositLimit;

  /**
   * Micro payment limits keyed by currency
   *
   * @generated from field: map<string, code.transaction.v2.MicroPaymentLimit> micro_payment_limits_by_currency = 4;
   */
  microPaymentLimitsByCurrency: { [key: string]: MicroPaymentLimit } = {};

  constructor(data?: PartialMessage<GetLimitsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetLimitsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetLimitsResponse_Result) },
    { no: 2, name: "remaining_send_limits_by_currency", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: RemainingSendLimit} },
    { no: 3, name: "deposit_limit", kind: "message", T: DepositLimit },
    { no: 4, name: "micro_payment_limits_by_currency", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: MicroPaymentLimit} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetLimitsResponse | PlainMessage<GetLimitsResponse> | undefined, b: GetLimitsResponse | PlainMessage<GetLimitsResponse> | undefined): boolean {
    return proto3.util.equals(GetLimitsResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetLimitsResponse.Result
 */
export enum GetLimitsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(GetLimitsResponse_Result)
proto3.util.setEnumType(GetLimitsResponse_Result, "code.transaction.v2.GetLimitsResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.transaction.v2.GetPaymentHistoryRequest
 */
export class GetPaymentHistoryRequest extends Message<GetPaymentHistoryRequest> {
  /**
   * The owner account to get payment history for
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * An optional history cursor indicating where in the history to resume from.
   *
   * @generated from field: code.transaction.v2.Cursor cursor = 2;
   */
  cursor?: Cursor;

  /**
   * The number of results to return per request. Default is 100.
   *
   * @generated from field: uint32 page_size = 3;
   */
  pageSize = 0;

  /**
   * The order in which to return history items from the cursor.
   *
   * @generated from field: code.transaction.v2.GetPaymentHistoryRequest.Direction direction = 4;
   */
  direction = GetPaymentHistoryRequest_Direction.ASC;

  /**
   * The signature is of serialize(GetPaymentHistoryRequest) without this field set
   * using the private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetPaymentHistoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetPaymentHistoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "cursor", kind: "message", T: Cursor },
    { no: 3, name: "page_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "direction", kind: "enum", T: proto3.getEnumType(GetPaymentHistoryRequest_Direction) },
    { no: 5, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPaymentHistoryRequest {
    return new GetPaymentHistoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPaymentHistoryRequest {
    return new GetPaymentHistoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPaymentHistoryRequest {
    return new GetPaymentHistoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetPaymentHistoryRequest | PlainMessage<GetPaymentHistoryRequest> | undefined, b: GetPaymentHistoryRequest | PlainMessage<GetPaymentHistoryRequest> | undefined): boolean {
    return proto3.util.equals(GetPaymentHistoryRequest, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetPaymentHistoryRequest.Direction
 */
export enum GetPaymentHistoryRequest_Direction {
  /**
   * ASC direction returns all history items in ascending order.
   *
   * @generated from enum value: ASC = 0;
   */
  ASC = 0,

  /**
   * DESC direction returns all history items in descending order.
   *
   * @generated from enum value: DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetPaymentHistoryRequest_Direction)
proto3.util.setEnumType(GetPaymentHistoryRequest_Direction, "code.transaction.v2.GetPaymentHistoryRequest.Direction", [
  { no: 0, name: "ASC" },
  { no: 1, name: "DESC" },
]);

/**
 * @generated from message code.transaction.v2.GetPaymentHistoryResponse
 */
export class GetPaymentHistoryResponse extends Message<GetPaymentHistoryResponse> {
  /**
   * @generated from field: code.transaction.v2.GetPaymentHistoryResponse.Result result = 1;
   */
  result = GetPaymentHistoryResponse_Result.OK;

  /**
   * @generated from field: repeated code.transaction.v2.PaymentHistoryItem items = 2;
   */
  items: PaymentHistoryItem[] = [];

  constructor(data?: PartialMessage<GetPaymentHistoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetPaymentHistoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetPaymentHistoryResponse_Result) },
    { no: 2, name: "items", kind: "message", T: PaymentHistoryItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPaymentHistoryResponse {
    return new GetPaymentHistoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPaymentHistoryResponse {
    return new GetPaymentHistoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPaymentHistoryResponse {
    return new GetPaymentHistoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetPaymentHistoryResponse | PlainMessage<GetPaymentHistoryResponse> | undefined, b: GetPaymentHistoryResponse | PlainMessage<GetPaymentHistoryResponse> | undefined): boolean {
    return proto3.util.equals(GetPaymentHistoryResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetPaymentHistoryResponse.Result
 */
export enum GetPaymentHistoryResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetPaymentHistoryResponse_Result)
proto3.util.setEnumType(GetPaymentHistoryResponse_Result, "code.transaction.v2.GetPaymentHistoryResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.transaction.v2.CanWithdrawToAccountRequest
 */
export class CanWithdrawToAccountRequest extends Message<CanWithdrawToAccountRequest> {
  /**
   * @generated from field: code.common.v1.SolanaAccountId account = 1;
   */
  account?: SolanaAccountId;

  constructor(data?: PartialMessage<CanWithdrawToAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CanWithdrawToAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CanWithdrawToAccountRequest | PlainMessage<CanWithdrawToAccountRequest> | undefined, b: CanWithdrawToAccountRequest | PlainMessage<CanWithdrawToAccountRequest> | undefined): boolean {
    return proto3.util.equals(CanWithdrawToAccountRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.CanWithdrawToAccountResponse
 */
export class CanWithdrawToAccountResponse extends Message<CanWithdrawToAccountResponse> {
  /**
   * Metadata so the client knows how to withdraw to the account. Server cannot
   * provide precalculated addresses in this response to maintain non-custodial
   * status.
   *
   * @generated from field: code.transaction.v2.CanWithdrawToAccountResponse.AccountType account_type = 2;
   */
  accountType = CanWithdrawToAccountResponse_AccountType.Unknown;

  /**
   * Server-controlled flag to indicate if the account can be withdrawn to.
   * There are several reasons server may deny it, including:
   *  - Wrong type of Code account
   *  - Not wanting to subsidize the creation of an ATA
   *  - Unsupported external account type (eg. token account but of the wrong mint)
   * This is guaranteed to be false when account_type = Unknown.
   *
   * @generated from field: bool is_valid_payment_destination = 1;
   */
  isValidPaymentDestination = false;

  /**
   * Token account requires initialization before the withdrawal can occur.
   * Server has chosen not to subsidize the fees. The response is guaranteed
   * to have set is_valid_payment_destination = false in this case.
   *
   * @generated from field: bool requires_initialization = 3;
   */
  requiresInitialization = false;

  constructor(data?: PartialMessage<CanWithdrawToAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CanWithdrawToAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "account_type", kind: "enum", T: proto3.getEnumType(CanWithdrawToAccountResponse_AccountType) },
    { no: 1, name: "is_valid_payment_destination", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "requires_initialization", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CanWithdrawToAccountResponse | PlainMessage<CanWithdrawToAccountResponse> | undefined, b: CanWithdrawToAccountResponse | PlainMessage<CanWithdrawToAccountResponse> | undefined): boolean {
    return proto3.util.equals(CanWithdrawToAccountResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.CanWithdrawToAccountResponse.AccountType
 */
export enum CanWithdrawToAccountResponse_AccountType {
  /**
   * Server cannot determine
   *
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * Client uses the address as is in SubmitIntent
   *
   * @generated from enum value: TokenAccount = 1;
   */
  TokenAccount = 1,

  /**
   * Client locally derives the ATA to use in SubmitIntent
   *
   * @generated from enum value: OwnerAccount = 2;
   */
  OwnerAccount = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(CanWithdrawToAccountResponse_AccountType)
proto3.util.setEnumType(CanWithdrawToAccountResponse_AccountType, "code.transaction.v2.CanWithdrawToAccountResponse.AccountType", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "TokenAccount" },
  { no: 2, name: "OwnerAccount" },
]);

/**
 * @generated from message code.transaction.v2.AirdropRequest
 */
export class AirdropRequest extends Message<AirdropRequest> {
  /**
   * The type of airdrop to claim
   *
   * @generated from field: code.transaction.v2.AirdropType airdrop_type = 1;
   */
  airdropType = AirdropType.UNKNOWN;

  /**
   * The owner account to airdrop Kin to
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(AirdropRequest) without this field set
   * using the private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<AirdropRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.AirdropRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "airdrop_type", kind: "enum", T: proto3.getEnumType(AirdropType) },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirdropRequest {
    return new AirdropRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirdropRequest {
    return new AirdropRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirdropRequest {
    return new AirdropRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AirdropRequest | PlainMessage<AirdropRequest> | undefined, b: AirdropRequest | PlainMessage<AirdropRequest> | undefined): boolean {
    return proto3.util.equals(AirdropRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.AirdropResponse
 */
export class AirdropResponse extends Message<AirdropResponse> {
  /**
   * @generated from field: code.transaction.v2.AirdropResponse.Result result = 1;
   */
  result = AirdropResponse_Result.OK;

  /**
   * Exchange data for the amount of Kin airdropped when successful
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 2;
   */
  exchangeData?: ExchangeData;

  constructor(data?: PartialMessage<AirdropResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.AirdropResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(AirdropResponse_Result) },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirdropResponse {
    return new AirdropResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirdropResponse {
    return new AirdropResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirdropResponse {
    return new AirdropResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AirdropResponse | PlainMessage<AirdropResponse> | undefined, b: AirdropResponse | PlainMessage<AirdropResponse> | undefined): boolean {
    return proto3.util.equals(AirdropResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.AirdropResponse.Result
 */
export enum AirdropResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * Airdrops are unavailable
   *
   * @generated from enum value: UNAVAILABLE = 1;
   */
  UNAVAILABLE = 1,

  /**
   * The airdrop has already been claimed by the owner
   *
   * @generated from enum value: ALREADY_CLAIMED = 2;
   */
  ALREADY_CLAIMED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AirdropResponse_Result)
proto3.util.setEnumType(AirdropResponse_Result, "code.transaction.v2.AirdropResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "UNAVAILABLE" },
  { no: 2, name: "ALREADY_CLAIMED" },
]);

/**
 * Metadata describes the high-level details of an intent
 *
 * @generated from message code.transaction.v2.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * @generated from oneof code.transaction.v2.Metadata.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountsMetadata open_accounts = 1;
     */
    value: OpenAccountsMetadata;
    case: "openAccounts";
  } | {
    /**
     * @generated from field: code.transaction.v2.SendPrivatePaymentMetadata send_private_payment = 2;
     */
    value: SendPrivatePaymentMetadata;
    case: "sendPrivatePayment";
  } | {
    /**
     * @generated from field: code.transaction.v2.ReceivePaymentsPrivatelyMetadata receive_payments_privately = 3;
     */
    value: ReceivePaymentsPrivatelyMetadata;
    case: "receivePaymentsPrivately";
  } | {
    /**
     * @generated from field: code.transaction.v2.UpgradePrivacyMetadata upgrade_privacy = 4;
     */
    value: UpgradePrivacyMetadata;
    case: "upgradePrivacy";
  } | {
    /**
     * @generated from field: code.transaction.v2.MigrateToPrivacy2022Metadata migrate_to_privacy_2022 = 5;
     */
    value: MigrateToPrivacy2022Metadata;
    case: "migrateToPrivacy2022";
  } | {
    /**
     * @generated from field: code.transaction.v2.SendPublicPaymentMetadata send_public_payment = 6;
     */
    value: SendPublicPaymentMetadata;
    case: "sendPublicPayment";
  } | {
    /**
     * @generated from field: code.transaction.v2.ReceivePaymentsPubliclyMetadata receive_payments_publicly = 7;
     */
    value: ReceivePaymentsPubliclyMetadata;
    case: "receivePaymentsPublicly";
  } | {
    /**
     * @generated from field: code.transaction.v2.EstablishRelationshipMetadata establish_relationship = 8;
     */
    value: EstablishRelationshipMetadata;
    case: "establishRelationship";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "open_accounts", kind: "message", T: OpenAccountsMetadata, oneof: "type" },
    { no: 2, name: "send_private_payment", kind: "message", T: SendPrivatePaymentMetadata, oneof: "type" },
    { no: 3, name: "receive_payments_privately", kind: "message", T: ReceivePaymentsPrivatelyMetadata, oneof: "type" },
    { no: 4, name: "upgrade_privacy", kind: "message", T: UpgradePrivacyMetadata, oneof: "type" },
    { no: 5, name: "migrate_to_privacy_2022", kind: "message", T: MigrateToPrivacy2022Metadata, oneof: "type" },
    { no: 6, name: "send_public_payment", kind: "message", T: SendPublicPaymentMetadata, oneof: "type" },
    { no: 7, name: "receive_payments_publicly", kind: "message", T: ReceivePaymentsPubliclyMetadata, oneof: "type" },
    { no: 8, name: "establish_relationship", kind: "message", T: EstablishRelationshipMetadata, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * Open a set of accounts. Currently, clients should only use this for new users
 * to open all required accounts up front (buckets, incoming, and outgoing).
 *
 * Action Spec:
 *
 * actions = [OpenAccountAction(PRIMARY)]
 * for account in [TEMPORARY_INCOMING, TEMPORARY_OUTGOING, BUCKET_1_KIN, ... , BUCKET_1_000_000_KIN]
 *   actions.push_back(OpenAccountAction(account))
 *   actions.push_back(CloseDormantAccount(account))
 *
 * Nothing is currently required
 *
 * @generated from message code.transaction.v2.OpenAccountsMetadata
 */
export class OpenAccountsMetadata extends Message<OpenAccountsMetadata> {
  constructor(data?: PartialMessage<OpenAccountsMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountsMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountsMetadata | PlainMessage<OpenAccountsMetadata> | undefined, b: OpenAccountsMetadata | PlainMessage<OpenAccountsMetadata> | undefined): boolean {
    return proto3.util.equals(OpenAccountsMetadata, a, b);
  }
}

/**
 * Sends a payment to a destination account with initial temporary privacy. Clients
 * should also reorganize their bucket accounts and rotate their temporary outgoing
 * account.
 *
 * Action Spec (In Person Cash Payment or Withdrawal):
 *
 * actions = [
 *   // Section 1: Transfer ExchangeData.Quarks from BUCKET_X_KIN accounts to TEMPORARY_OUTGOING account with reogranizations
 *
 *   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
 *   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
 *   ...,
 *   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
 *   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
 *
 *   // Section 2: Rotate TEMPORARY_OUTGOING account
 *
 *   // Below must appear last in this exact order
 *   NoPrivacyWithdrawAction(TEMPORARY_OUTGOING[index], destination, ExchangeData.Quarks),
 *   OpenAccountAction(TEMPORARY_OUTGOING[index + 1]),
 *   CloseDormantAccount(TEMPORARY_OUTGOING[index + 1]),
 * ]
 *
 * Action Spec (Remote Send):
 *
 * actions = [
 *   // Section 1: Open REMOTE_SEND_GIFT_CARD account
 *
 *   OpenAccountAction(REMOTE_SEND_GIFT_CARD),
 *
 *   // Section 2: Transfer ExchangeData.Quarks from BUCKET_X_KIN accounts to TEMPORARY_OUTGOING account with reogranizations
 *
 *   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
 *   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
 *   ...,
 *   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
 *   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
 *
 *   // Section 3: Rotate TEMPORARY_OUTGOING account
 *
 *   // Below must appear last in this exact order
 *   NoPrivacyWithdrawAction(TEMPORARY_OUTGOING[index], REMOTE_SEND_GIFT_CARD, ExchangeData.Quarks),
 *   OpenAccountAction(TEMPORARY_OUTGOING[index + 1]),
 *   CloseDormantAccount(TEMPORARY_OUTGOING[index + 1]),
 *
 *   // Section 4: Close REMOTE_SEND_GIFT_CARD if not redeemed after period of time
 *
 *   CloseDormantAccount(REMOTE_SEND_GIFT_CARD),
 *
 * Action Spec (Micro Payment):
 *
 * actions = [
 *   // Section 1: Transfer ExchangeData.Quarks from BUCKET_X_KIN accounts to TEMPORARY_OUTGOING account with reogranizations
 *
 *   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
 *   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
 *   ...,
 *   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
 *   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
 *
 *   // Section 2: Rotate TEMPORARY_OUTGOING account
 *
 *   // Below must appear last in this exact order
 *   FeePayment(TEMPORARY_OUTGOING[index], feeAccount, $0.01 USD of Kin),
 *   NoPrivacyWithdrawAction(TEMPORARY_OUTGOING[index], destination, ExchangeData.Quarks - $0.01 USD of Kin),
 *   OpenAccountAction(TEMPORARY_OUTGOING[index + 1]),
 *   CloseDormantAccount(TEMPORARY_OUTGOING[index + 1]),
 * ]
 *
 * @generated from message code.transaction.v2.SendPrivatePaymentMetadata
 */
export class SendPrivatePaymentMetadata extends Message<SendPrivatePaymentMetadata> {
  /**
   * The destination token account to send funds to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  /**
   * The exchange data of total funds being sent to the destination
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 2;
   */
  exchangeData?: ExchangeData;

  /**
   * Is the payment a withdrawal? For destinations that are not Code temporary
   * accounts, this must be set to true.
   *
   * @generated from field: bool is_withdrawal = 3;
   */
  isWithdrawal = false;

  /**
   * Is the payment for a remote send?
   *
   * @generated from field: bool is_remote_send = 4;
   */
  isRemoteSend = false;

  constructor(data?: PartialMessage<SendPrivatePaymentMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SendPrivatePaymentMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeData },
    { no: 3, name: "is_withdrawal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "is_remote_send", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendPrivatePaymentMetadata {
    return new SendPrivatePaymentMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendPrivatePaymentMetadata {
    return new SendPrivatePaymentMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendPrivatePaymentMetadata {
    return new SendPrivatePaymentMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SendPrivatePaymentMetadata | PlainMessage<SendPrivatePaymentMetadata> | undefined, b: SendPrivatePaymentMetadata | PlainMessage<SendPrivatePaymentMetadata> | undefined): boolean {
    return proto3.util.equals(SendPrivatePaymentMetadata, a, b);
  }
}

/**
 * Send a payment to a destination account publicly.
 *
 * Action Spec:
 *
 * source = PRIMARY or RELATIONSHIP
 * actions = [NoPrivacyTransferAction(source, destination, ExchangeData.Quarks)]
 *
 * @generated from message code.transaction.v2.SendPublicPaymentMetadata
 */
export class SendPublicPaymentMetadata extends Message<SendPublicPaymentMetadata> {
  /**
   * The primary or relatinship account where funds will be sent from. The primary
   * account is assumed if this field is not set for backwards compatibility with
   * old clients.
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 4;
   */
  source?: SolanaAccountId;

  /**
   * The destination token account to send funds to. This cannot be a Code
   * temporary account.
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  /**
   * The exchange data of total funds being sent to the destination
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 2;
   */
  exchangeData?: ExchangeData;

  /**
   * Is the payment a withdrawal? Currently, this is always true.
   *
   * @generated from field: bool is_withdrawal = 3;
   */
  isWithdrawal = false;

  constructor(data?: PartialMessage<SendPublicPaymentMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SendPublicPaymentMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "source", kind: "message", T: SolanaAccountId },
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeData },
    { no: 3, name: "is_withdrawal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SendPublicPaymentMetadata | PlainMessage<SendPublicPaymentMetadata> | undefined, b: SendPublicPaymentMetadata | PlainMessage<SendPublicPaymentMetadata> | undefined): boolean {
    return proto3.util.equals(SendPublicPaymentMetadata, a, b);
  }
}

/**
 * Receive funds into an organizer with initial temporary privacy. Clients should
 * also reorganize their bucket accounts and rotate their temporary incoming account
 * as applicable. Only accounts owned and derived by a user's 12 words should operate
 * as a source in this intent type to guarantee privacy upgradeability.
 *
 * Action Spec (Payment):
 *
 * actions = [
 *   // Section 1: Transfer Quarks from TEMPORARY_INCOMING account to BUCKET_X_KIN accounts with reorganizations
 *
 *   TemporaryPrivacyTransferAction(TEMPORARY_INCOMING[index], BUCKET_X_KIN, multiple * bucketSize),
 *   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
 *   ...,
 *   TemporaryPrivacyTransferAction(TEMPORARY_INCOMING[index], BUCKET_X_KIN, multiple * bucketSize),
 *   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
 *
 *   // Section 2: Rotate TEMPORARY_INCOMING account
 *
 *   // Below must appear last in this exact order
 *   CloseEmptyAccountAction(TEMPORARY_INCOMING[index]),
 *   OpenAccountAction(TEMPORARY_INCOMING[index + 1])
 *   CloseDormantAccount(TEMPORARY_INCOMING[index + 1]),
 * ]
 *
 * Action Spec (Deposit):
 *
 * source = PRIMARY or RELATIONSHIP
 * actions = [
 *   TemporaryPrivacyTransferAction(source, BUCKET_X_KIN, multiple * bucketSize),
 *   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
 *   ...,
 *   TemporaryPrivacyTransferAction(source, BUCKET_X_KIN, multiple * bucketSize),
 *   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
 * ]
 *
 * @generated from message code.transaction.v2.ReceivePaymentsPrivatelyMetadata
 */
export class ReceivePaymentsPrivatelyMetadata extends Message<ReceivePaymentsPrivatelyMetadata> {
  /**
   * The temporary incoming, primary or relationship account to receive funds from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 1;
   */
  source?: SolanaAccountId;

  /**
   * The exact amount of Kin in quarks being received
   *
   * @generated from field: uint64 quarks = 2;
   */
  quarks = protoInt64.zero;

  /**
   * Is the receipt of funds from a deposit? If true, the source account must
   * be a primary or relationship account. Otherwise, it must be from a temporary
   * incoming account.
   *
   * @generated from field: bool is_deposit = 3;
   */
  isDeposit = false;

  constructor(data?: PartialMessage<ReceivePaymentsPrivatelyMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ReceivePaymentsPrivatelyMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: SolanaAccountId },
    { no: 2, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "is_deposit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReceivePaymentsPrivatelyMetadata {
    return new ReceivePaymentsPrivatelyMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReceivePaymentsPrivatelyMetadata {
    return new ReceivePaymentsPrivatelyMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReceivePaymentsPrivatelyMetadata {
    return new ReceivePaymentsPrivatelyMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ReceivePaymentsPrivatelyMetadata | PlainMessage<ReceivePaymentsPrivatelyMetadata> | undefined, b: ReceivePaymentsPrivatelyMetadata | PlainMessage<ReceivePaymentsPrivatelyMetadata> | undefined): boolean {
    return proto3.util.equals(ReceivePaymentsPrivatelyMetadata, a, b);
  }
}

/**
 * Receive funds into a user-owned account publicly. All use cases of this intent
 * close the account, so all funds must be moved. Use this intent to receive payments
 * from an account not owned by a user's 12 words into a temporary incoming account,
 * which will guarantee privacy upgradeability.
 *
 * Action Spec (Remote Send):
 *
 * actions = [NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, TEMPORARY_INCOMING[latest_index], quarks)]
 *
 * @generated from message code.transaction.v2.ReceivePaymentsPubliclyMetadata
 */
export class ReceivePaymentsPubliclyMetadata extends Message<ReceivePaymentsPubliclyMetadata> {
  /**
   * The remote send gift card to receive funds from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 1;
   */
  source?: SolanaAccountId;

  /**
   * The exact amount of Kin in quarks being received
   *
   * @generated from field: uint64 quarks = 2;
   */
  quarks = protoInt64.zero;

  /**
   * Is the receipt of funds from a remote send gift card? Currently, this is
   * the only use case for this intent and validation enforces the flag to true.
   *
   * @generated from field: bool is_remote_send = 3;
   */
  isRemoteSend = false;

  /**
   * If is_remote_send is true, is the gift card being voided? The user owner
   * account's 12 words that issued the gift card may only set this flag to true.
   * Functionally, this doesn't affect the intent, but rather if we decide to show
   * it in a user-friendly payment history.
   *
   * @generated from field: bool is_issuer_voiding_gift_card = 4;
   */
  isIssuerVoidingGiftCard = false;

  /**
   * If is_remote_send is true, the original exchange data that was provided as
   * part of creating the gift card account. This is purely a server-provided value.
   * SubmitIntent will disallow this being set.
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 5;
   */
  exchangeData?: ExchangeData;

  constructor(data?: PartialMessage<ReceivePaymentsPubliclyMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ReceivePaymentsPubliclyMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: SolanaAccountId },
    { no: 2, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "is_remote_send", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "is_issuer_voiding_gift_card", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "exchange_data", kind: "message", T: ExchangeData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ReceivePaymentsPubliclyMetadata | PlainMessage<ReceivePaymentsPubliclyMetadata> | undefined, b: ReceivePaymentsPubliclyMetadata | PlainMessage<ReceivePaymentsPubliclyMetadata> | undefined): boolean {
    return proto3.util.equals(ReceivePaymentsPubliclyMetadata, a, b);
  }
}

/**
 * Upgrade existing private transactions from temporary to permanent privacy.
 *
 * Nothing is currently required
 *
 * @generated from message code.transaction.v2.UpgradePrivacyMetadata
 */
export class UpgradePrivacyMetadata extends Message<UpgradePrivacyMetadata> {
  constructor(data?: PartialMessage<UpgradePrivacyMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.UpgradePrivacyMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradePrivacyMetadata {
    return new UpgradePrivacyMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradePrivacyMetadata {
    return new UpgradePrivacyMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradePrivacyMetadata {
    return new UpgradePrivacyMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradePrivacyMetadata | PlainMessage<UpgradePrivacyMetadata> | undefined, b: UpgradePrivacyMetadata | PlainMessage<UpgradePrivacyMetadata> | undefined): boolean {
    return proto3.util.equals(UpgradePrivacyMetadata, a, b);
  }
}

/**
 * Migrates existing users prior to the privacy implementation by:
 *  1. If there are funds in the LEGACY_PRIMARY_2022 account, then move them
 *     to the new PRIMARY account, so the client can later simulate a deposit
 *     by submitting a *separate* ReceivePaymentsPrivately intent.
 *  2. Close the LEGACY_PRIMARY_2022 account.
 *
 * Prereqs:
 *  - OpenAccounts intent has been submitted
 *
 * Action spec:
 *
 * if balance == 0 {
 *    actions = [CloseEmptyAccountAction(LEGACY_PRIMARY_2022)]
 * } else {
 *    actions = [NoPrivacyWitdraw(LEGACY_PRIMARY_2022, PRIMARY, Quarks)]
 * }
 *
 * @generated from message code.transaction.v2.MigrateToPrivacy2022Metadata
 */
export class MigrateToPrivacy2022Metadata extends Message<MigrateToPrivacy2022Metadata> {
  /**
   * The exact amount of Kin in quarks being migrated. Set this to zero if
   * the account is empty.
   *
   * @generated from field: uint64 quarks = 1;
   */
  quarks = protoInt64.zero;

  constructor(data?: PartialMessage<MigrateToPrivacy2022Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.MigrateToPrivacy2022Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MigrateToPrivacy2022Metadata {
    return new MigrateToPrivacy2022Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MigrateToPrivacy2022Metadata {
    return new MigrateToPrivacy2022Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MigrateToPrivacy2022Metadata {
    return new MigrateToPrivacy2022Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: MigrateToPrivacy2022Metadata | PlainMessage<MigrateToPrivacy2022Metadata> | undefined, b: MigrateToPrivacy2022Metadata | PlainMessage<MigrateToPrivacy2022Metadata> | undefined): boolean {
    return proto3.util.equals(MigrateToPrivacy2022Metadata, a, b);
  }
}

/**
 * Establishes a long-lived private relationship between a user and another
 * entity.
 *
 * Prereqs:
 *  - OpenAccounts intent has been submitted
 *
 * Action spec:
 *
 * actions = [OpenAccountAction(RELATIONSHIP)]
 *
 * @generated from message code.transaction.v2.EstablishRelationshipMetadata
 */
export class EstablishRelationshipMetadata extends Message<EstablishRelationshipMetadata> {
  /**
   * @generated from field: code.common.v1.Relationship relationship = 1;
   */
  relationship?: Relationship;

  constructor(data?: PartialMessage<EstablishRelationshipMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.EstablishRelationshipMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relationship", kind: "message", T: Relationship },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstablishRelationshipMetadata {
    return new EstablishRelationshipMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstablishRelationshipMetadata {
    return new EstablishRelationshipMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstablishRelationshipMetadata {
    return new EstablishRelationshipMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: EstablishRelationshipMetadata | PlainMessage<EstablishRelationshipMetadata> | undefined, b: EstablishRelationshipMetadata | PlainMessage<EstablishRelationshipMetadata> | undefined): boolean {
    return proto3.util.equals(EstablishRelationshipMetadata, a, b);
  }
}

/**
 * Action is a well-defined, ordered and small set of transactions for a unit of work
 * that the client wants to perform on the blockchain. Clients provide parameters known
 * to them in the action.
 *
 * @generated from message code.transaction.v2.Action
 */
export class Action extends Message<Action> {
  /**
   * The ID of this action, which is unique within an intent. It must match
   * the index of the action's location in the SubmitAction's actions field.
   *
   * @generated from field: uint32 id = 1;
   */
  id = 0;

  /**
   * The type of action to perform.
   *
   * @generated from oneof code.transaction.v2.Action.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountAction open_account = 2;
     */
    value: OpenAccountAction;
    case: "openAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.CloseEmptyAccountAction close_empty_account = 3;
     */
    value: CloseEmptyAccountAction;
    case: "closeEmptyAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.CloseDormantAccountAction close_dormant_account = 4;
     */
    value: CloseDormantAccountAction;
    case: "closeDormantAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyTransferAction no_privacy_transfer = 5;
     */
    value: NoPrivacyTransferAction;
    case: "noPrivacyTransfer";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyWithdrawAction no_privacy_withdraw = 6;
     */
    value: NoPrivacyWithdrawAction;
    case: "noPrivacyWithdraw";
  } | {
    /**
     * @generated from field: code.transaction.v2.TemporaryPrivacyTransferAction temporary_privacy_transfer = 7;
     */
    value: TemporaryPrivacyTransferAction;
    case: "temporaryPrivacyTransfer";
  } | {
    /**
     * @generated from field: code.transaction.v2.TemporaryPrivacyExchangeAction temporary_privacy_exchange = 8;
     */
    value: TemporaryPrivacyExchangeAction;
    case: "temporaryPrivacyExchange";
  } | {
    /**
     * @generated from field: code.transaction.v2.PermanentPrivacyUpgradeAction permanent_privacy_upgrade = 9;
     */
    value: PermanentPrivacyUpgradeAction;
    case: "permanentPrivacyUpgrade";
  } | {
    /**
     * @generated from field: code.transaction.v2.FeePaymentAction fee_payment = 10;
     */
    value: FeePaymentAction;
    case: "feePayment";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Action>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.Action";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "open_account", kind: "message", T: OpenAccountAction, oneof: "type" },
    { no: 3, name: "close_empty_account", kind: "message", T: CloseEmptyAccountAction, oneof: "type" },
    { no: 4, name: "close_dormant_account", kind: "message", T: CloseDormantAccountAction, oneof: "type" },
    { no: 5, name: "no_privacy_transfer", kind: "message", T: NoPrivacyTransferAction, oneof: "type" },
    { no: 6, name: "no_privacy_withdraw", kind: "message", T: NoPrivacyWithdrawAction, oneof: "type" },
    { no: 7, name: "temporary_privacy_transfer", kind: "message", T: TemporaryPrivacyTransferAction, oneof: "type" },
    { no: 8, name: "temporary_privacy_exchange", kind: "message", T: TemporaryPrivacyExchangeAction, oneof: "type" },
    { no: 9, name: "permanent_privacy_upgrade", kind: "message", T: PermanentPrivacyUpgradeAction, oneof: "type" },
    { no: 10, name: "fee_payment", kind: "message", T: FeePaymentAction, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Action {
    return new Action().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJsonString(jsonString, options);
  }

  static equals(a: Action | PlainMessage<Action> | undefined, b: Action | PlainMessage<Action> | undefined): boolean {
    return proto3.util.equals(Action, a, b);
  }
}

/**
 * Transaction 1
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. timelock::Initialize
 *  Client Signature Required: No
 *
 * All OpenAccountActions for non-primary accounts must be followed with an associated
 * CloseDormantAccountAction to enable server to perform cleanup.
 *
 * @generated from message code.transaction.v2.OpenAccountAction
 */
export class OpenAccountAction extends Message<OpenAccountAction> {
  /**
   * The type of account, which will dictate its intended use
   *
   * @generated from field: code.common.v1.AccountType account_type = 1;
   */
  accountType = AccountType.UNKNOWN;

  /**
   * The owner of the account. For accounts liked to a user's 12 words, this is
   * the verified parent owner account public key. All other account types should
   * set this to the authority value.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The index used to for accounts that are derived from owner
   *
   * @generated from field: uint64 index = 3;
   */
  index = protoInt64.zero;

  /**
   * The public key of the private key that has authority over the opened token account
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 4;
   */
  authority?: SolanaAccountId;

  /**
   * The token account being opened
   *
   * @generated from field: code.common.v1.SolanaAccountId token = 5;
   */
  token?: SolanaAccountId;

  /**
   * The signature is of serialize(OpenAccountAction) without this field set
   * using the private key of the authority account. This provides a proof
   * of authorization to link authority to owner.
   *
   * @generated from field: code.common.v1.Signature authority_signature = 6;
   */
  authoritySignature?: Signature;

  constructor(data?: PartialMessage<OpenAccountAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_type", kind: "enum", T: proto3.getEnumType(AccountType) },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 5, name: "token", kind: "message", T: SolanaAccountId },
    { no: 6, name: "authority_signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountAction | PlainMessage<OpenAccountAction> | undefined, b: OpenAccountAction | PlainMessage<OpenAccountAction> | undefined): boolean {
    return proto3.util.equals(OpenAccountAction, a, b);
  }
}

/**
 * Transaction 1
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. timelock::BurnDustWithAuthority (max 1 Kin)
 *    3. timelock::CloseAccounts
 *  Client Signature Required: Yes
 *
 * @generated from message code.transaction.v2.CloseEmptyAccountAction
 */
export class CloseEmptyAccountAction extends Message<CloseEmptyAccountAction> {
  /**
   * The type of account being closed
   *
   * @generated from field: code.common.v1.AccountType account_type = 1;
   */
  accountType = AccountType.UNKNOWN;

  /**
   * The public key of the private key that has authority over the token account
   * that should be closed
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 2;
   */
  authority?: SolanaAccountId;

  /**
   * The token account being closed
   *
   * @generated from field: code.common.v1.SolanaAccountId token = 3;
   */
  token?: SolanaAccountId;

  constructor(data?: PartialMessage<CloseEmptyAccountAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CloseEmptyAccountAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_type", kind: "enum", T: proto3.getEnumType(AccountType) },
    { no: 2, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 3, name: "token", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloseEmptyAccountAction {
    return new CloseEmptyAccountAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloseEmptyAccountAction {
    return new CloseEmptyAccountAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloseEmptyAccountAction {
    return new CloseEmptyAccountAction().fromJsonString(jsonString, options);
  }

  static equals(a: CloseEmptyAccountAction | PlainMessage<CloseEmptyAccountAction> | undefined, b: CloseEmptyAccountAction | PlainMessage<CloseEmptyAccountAction> | undefined): boolean {
    return proto3.util.equals(CloseEmptyAccountAction, a, b);
  }
}

/**
 * Transaction 1
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. memo::Memo
 *    3. timelock::RevokeLockWithAuthority
 *    4. timelock::DeactivateLock
 *    5. timelock::Withdraw (token -> primary)
 *    6. timelock::CloseAccounts
 *  Client Signature Required: Yes
 *
 * @generated from message code.transaction.v2.CloseDormantAccountAction
 */
export class CloseDormantAccountAction extends Message<CloseDormantAccountAction> {
  /**
   * The type of account being closed
   *
   * @generated from field: code.common.v1.AccountType account_type = 1;
   */
  accountType = AccountType.UNKNOWN;

  /**
   * The public key of the private key that has authority over the token account
   * that should be closed
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 2;
   */
  authority?: SolanaAccountId;

  /**
   * The token account being closed
   *
   * @generated from field: code.common.v1.SolanaAccountId token = 3;
   */
  token?: SolanaAccountId;

  /**
   * The destination where funds are withdrawn to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 4;
   */
  destination?: SolanaAccountId;

  constructor(data?: PartialMessage<CloseDormantAccountAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CloseDormantAccountAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_type", kind: "enum", T: proto3.getEnumType(AccountType) },
    { no: 2, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 3, name: "token", kind: "message", T: SolanaAccountId },
    { no: 4, name: "destination", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloseDormantAccountAction {
    return new CloseDormantAccountAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloseDormantAccountAction {
    return new CloseDormantAccountAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloseDormantAccountAction {
    return new CloseDormantAccountAction().fromJsonString(jsonString, options);
  }

  static equals(a: CloseDormantAccountAction | PlainMessage<CloseDormantAccountAction> | undefined, b: CloseDormantAccountAction | PlainMessage<CloseDormantAccountAction> | undefined): boolean {
    return proto3.util.equals(CloseDormantAccountAction, a, b);
  }
}

/**
 * Transaction 1
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. memo::Memo
 *    3. timelock::TransferWithAuthority (source -> destination)
 *  Client Signature Required: Yes
 *
 * @generated from message code.transaction.v2.NoPrivacyTransferAction
 */
export class NoPrivacyTransferAction extends Message<NoPrivacyTransferAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The destination account where funds are transferred to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 3;
   */
  destination?: SolanaAccountId;

  /**
   * The Kin quark amount to transfer
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  constructor(data?: PartialMessage<NoPrivacyTransferAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyTransferAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyTransferAction | PlainMessage<NoPrivacyTransferAction> | undefined, b: NoPrivacyTransferAction | PlainMessage<NoPrivacyTransferAction> | undefined): boolean {
    return proto3.util.equals(NoPrivacyTransferAction, a, b);
  }
}

/**
 * Transaction 1
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. memo::Memo
 *    3. timelock::RevokeLockWithAuthority
 *    4. timelock::DeactivateLock
 *    5. timelock::Withdraw (source -> destination)
 *    6. timelock::CloseAccounts
 *  Client Signature Required: Yes
 *
 * @generated from message code.transaction.v2.NoPrivacyWithdrawAction
 */
export class NoPrivacyWithdrawAction extends Message<NoPrivacyWithdrawAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The destination account where funds are transferred to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 3;
   */
  destination?: SolanaAccountId;

  /**
   * The intended Kin quark amount to withdraw
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  /**
   * Whether the account is closed afterwards. This is always true, since there
   * are no current se cases to leave it open.
   *
   * @generated from field: bool should_close = 5;
   */
  shouldClose = false;

  constructor(data?: PartialMessage<NoPrivacyWithdrawAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyWithdrawAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "should_close", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyWithdrawAction | PlainMessage<NoPrivacyWithdrawAction> | undefined, b: NoPrivacyWithdrawAction | PlainMessage<NoPrivacyWithdrawAction> | undefined): boolean {
    return proto3.util.equals(NoPrivacyWithdrawAction, a, b);
  }
}

/**
 * Transaction 1
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. memo::Memo
 *    3. splitter::TransferWithCommitment (treasury -> destination)
 *  Client Signature Required: No
 *
 * Transaction 2
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. memo::Memo
 *    3. timelock::TransferWithAuthority (source -> commitment)
 *  Client Signature Required: Yes
 *
 * @generated from message code.transaction.v2.TemporaryPrivacyTransferAction
 */
export class TemporaryPrivacyTransferAction extends Message<TemporaryPrivacyTransferAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The destination account where funds are transferred to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 3;
   */
  destination?: SolanaAccountId;

  /**
   * The Kin quark amount to transfer
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  constructor(data?: PartialMessage<TemporaryPrivacyTransferAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.TemporaryPrivacyTransferAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TemporaryPrivacyTransferAction {
    return new TemporaryPrivacyTransferAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TemporaryPrivacyTransferAction {
    return new TemporaryPrivacyTransferAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TemporaryPrivacyTransferAction {
    return new TemporaryPrivacyTransferAction().fromJsonString(jsonString, options);
  }

  static equals(a: TemporaryPrivacyTransferAction | PlainMessage<TemporaryPrivacyTransferAction> | undefined, b: TemporaryPrivacyTransferAction | PlainMessage<TemporaryPrivacyTransferAction> | undefined): boolean {
    return proto3.util.equals(TemporaryPrivacyTransferAction, a, b);
  }
}

/**
 * Transaction 1
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. memo::Memo
 *    3. splitter::TransferWithCommitment (treasury -> destination)
 *  Client Signature Required: No
 *
 * Transaction 2
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. memo::Memo
 *    3. timelock::TransferWithAuthority (source -> commitment)
 *  Client Signature Required: Yes
 *
 * @generated from message code.transaction.v2.TemporaryPrivacyExchangeAction
 */
export class TemporaryPrivacyExchangeAction extends Message<TemporaryPrivacyExchangeAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are exchanged from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The destination account where funds are exchanged to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 3;
   */
  destination?: SolanaAccountId;

  /**
   * The Kin quark amount to exchange
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  constructor(data?: PartialMessage<TemporaryPrivacyExchangeAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.TemporaryPrivacyExchangeAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TemporaryPrivacyExchangeAction {
    return new TemporaryPrivacyExchangeAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TemporaryPrivacyExchangeAction {
    return new TemporaryPrivacyExchangeAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TemporaryPrivacyExchangeAction {
    return new TemporaryPrivacyExchangeAction().fromJsonString(jsonString, options);
  }

  static equals(a: TemporaryPrivacyExchangeAction | PlainMessage<TemporaryPrivacyExchangeAction> | undefined, b: TemporaryPrivacyExchangeAction | PlainMessage<TemporaryPrivacyExchangeAction> | undefined): boolean {
    return proto3.util.equals(TemporaryPrivacyExchangeAction, a, b);
  }
}

/**
 * Transaction 1
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. memo::Memo
 *    3. timelock::TransferWithAuthority (source -> different commitment)
 *  Client Signature Required: Yes
 *
 * @generated from message code.transaction.v2.PermanentPrivacyUpgradeAction
 */
export class PermanentPrivacyUpgradeAction extends Message<PermanentPrivacyUpgradeAction> {
  /**
   * The action ID of the temporary private transfer or exchange to upgrade
   *
   * @generated from field: uint32 action_id = 1;
   */
  actionId = 0;

  constructor(data?: PartialMessage<PermanentPrivacyUpgradeAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.PermanentPrivacyUpgradeAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PermanentPrivacyUpgradeAction {
    return new PermanentPrivacyUpgradeAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PermanentPrivacyUpgradeAction {
    return new PermanentPrivacyUpgradeAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PermanentPrivacyUpgradeAction {
    return new PermanentPrivacyUpgradeAction().fromJsonString(jsonString, options);
  }

  static equals(a: PermanentPrivacyUpgradeAction | PlainMessage<PermanentPrivacyUpgradeAction> | undefined, b: PermanentPrivacyUpgradeAction | PlainMessage<PermanentPrivacyUpgradeAction> | undefined): boolean {
    return proto3.util.equals(PermanentPrivacyUpgradeAction, a, b);
  }
}

/**
 * Transaction 1
 *  Instructions:
 *    1. system::AdvanceNonce
 *    2. memo::Memo
 *    3. timelock::TransferWithAuthority (source -> fee account)
 *  Client Signature Required: Yes
 *
 * Note: This is exactly a NoPrivacyTransferAction, except the destination
 *       account is controlled by Code and provided in a server parameter.
 * Note: The fee amount is hardcoded at the client and validated by server.
 *       Currently, its set to $0.01 USD.
 *
 * @generated from message code.transaction.v2.FeePaymentAction
 */
export class FeePaymentAction extends Message<FeePaymentAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The Kin quark amount to transfer
   *
   * @generated from field: uint64 amount = 3;
   */
  amount = protoInt64.zero;

  constructor(data?: PartialMessage<FeePaymentAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.FeePaymentAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromJsonString(jsonString, options);
  }

  static equals(a: FeePaymentAction | PlainMessage<FeePaymentAction> | undefined, b: FeePaymentAction | PlainMessage<FeePaymentAction> | undefined): boolean {
    return proto3.util.equals(FeePaymentAction, a, b);
  }
}

/**
 * ServerParameter are a set of parameters known and returned by server that
 * enables clients to complete transaction construction. Any necessary proofs,
 * which are required to be locally verifiable, are also provided to ensure
 * safe use in the event of a malicious server.
 *
 * @generated from message code.transaction.v2.ServerParameter
 */
export class ServerParameter extends Message<ServerParameter> {
  /**
   * The action the server parameters belong to
   *
   * @generated from field: uint32 action_id = 1;
   */
  actionId = 0;

  /**
   * The set of nonces used for the action. Server will only provide values
   * for transactions requiring client signatures.
   *
   * @generated from field: repeated code.transaction.v2.NoncedTransactionMetadata nonces = 2;
   */
  nonces: NoncedTransactionMetadata[] = [];

  /**
   * The type of server parameter which maps to the type of action requested
   *
   * @generated from oneof code.transaction.v2.ServerParameter.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountServerParameter open_account = 3;
     */
    value: OpenAccountServerParameter;
    case: "openAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.CloseEmptyAccountServerParameter close_empty_account = 4;
     */
    value: CloseEmptyAccountServerParameter;
    case: "closeEmptyAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.CloseDormantAccountServerParameter close_dormant_account = 5;
     */
    value: CloseDormantAccountServerParameter;
    case: "closeDormantAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyTransferServerParameter no_privacy_transfer = 6;
     */
    value: NoPrivacyTransferServerParameter;
    case: "noPrivacyTransfer";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyWithdrawServerParameter no_privacy_withdraw = 7;
     */
    value: NoPrivacyWithdrawServerParameter;
    case: "noPrivacyWithdraw";
  } | {
    /**
     * @generated from field: code.transaction.v2.TemporaryPrivacyTransferServerParameter temporary_privacy_transfer = 8;
     */
    value: TemporaryPrivacyTransferServerParameter;
    case: "temporaryPrivacyTransfer";
  } | {
    /**
     * @generated from field: code.transaction.v2.TemporaryPrivacyExchangeServerParameter temporary_privacy_exchange = 9;
     */
    value: TemporaryPrivacyExchangeServerParameter;
    case: "temporaryPrivacyExchange";
  } | {
    /**
     * @generated from field: code.transaction.v2.PermanentPrivacyUpgradeServerParameter permanent_privacy_upgrade = 10;
     */
    value: PermanentPrivacyUpgradeServerParameter;
    case: "permanentPrivacyUpgrade";
  } | {
    /**
     * @generated from field: code.transaction.v2.FeePaymentServerParameter fee_payment = 11;
     */
    value: FeePaymentServerParameter;
    case: "feePayment";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "nonces", kind: "message", T: NoncedTransactionMetadata, repeated: true },
    { no: 3, name: "open_account", kind: "message", T: OpenAccountServerParameter, oneof: "type" },
    { no: 4, name: "close_empty_account", kind: "message", T: CloseEmptyAccountServerParameter, oneof: "type" },
    { no: 5, name: "close_dormant_account", kind: "message", T: CloseDormantAccountServerParameter, oneof: "type" },
    { no: 6, name: "no_privacy_transfer", kind: "message", T: NoPrivacyTransferServerParameter, oneof: "type" },
    { no: 7, name: "no_privacy_withdraw", kind: "message", T: NoPrivacyWithdrawServerParameter, oneof: "type" },
    { no: 8, name: "temporary_privacy_transfer", kind: "message", T: TemporaryPrivacyTransferServerParameter, oneof: "type" },
    { no: 9, name: "temporary_privacy_exchange", kind: "message", T: TemporaryPrivacyExchangeServerParameter, oneof: "type" },
    { no: 10, name: "permanent_privacy_upgrade", kind: "message", T: PermanentPrivacyUpgradeServerParameter, oneof: "type" },
    { no: 11, name: "fee_payment", kind: "message", T: FeePaymentServerParameter, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerParameter {
    return new ServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerParameter {
    return new ServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerParameter {
    return new ServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: ServerParameter | PlainMessage<ServerParameter> | undefined, b: ServerParameter | PlainMessage<ServerParameter> | undefined): boolean {
    return proto3.util.equals(ServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.NoncedTransactionMetadata
 */
export class NoncedTransactionMetadata extends Message<NoncedTransactionMetadata> {
  /**
   * The nonce account to use in the system::AdvanceNonce instruction
   *
   * @generated from field: code.common.v1.SolanaAccountId nonce = 1;
   */
  nonce?: SolanaAccountId;

  /**
   * The blockhash to set in the transaction
   *
   * @generated from field: code.common.v1.Blockhash blockhash = 2;
   */
  blockhash?: Blockhash;

  constructor(data?: PartialMessage<NoncedTransactionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoncedTransactionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "message", T: SolanaAccountId },
    { no: 2, name: "blockhash", kind: "message", T: Blockhash },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: NoncedTransactionMetadata | PlainMessage<NoncedTransactionMetadata> | undefined, b: NoncedTransactionMetadata | PlainMessage<NoncedTransactionMetadata> | undefined): boolean {
    return proto3.util.equals(NoncedTransactionMetadata, a, b);
  }
}

/**
 * There are no transactions requiring client signatures
 *
 * @generated from message code.transaction.v2.OpenAccountServerParameter
 */
export class OpenAccountServerParameter extends Message<OpenAccountServerParameter> {
  constructor(data?: PartialMessage<OpenAccountServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountServerParameter | PlainMessage<OpenAccountServerParameter> | undefined, b: OpenAccountServerParameter | PlainMessage<OpenAccountServerParameter> | undefined): boolean {
    return proto3.util.equals(OpenAccountServerParameter, a, b);
  }
}

/**
 * There are no action-specific server parameters
 *
 * @generated from message code.transaction.v2.CloseEmptyAccountServerParameter
 */
export class CloseEmptyAccountServerParameter extends Message<CloseEmptyAccountServerParameter> {
  constructor(data?: PartialMessage<CloseEmptyAccountServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CloseEmptyAccountServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloseEmptyAccountServerParameter {
    return new CloseEmptyAccountServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloseEmptyAccountServerParameter {
    return new CloseEmptyAccountServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloseEmptyAccountServerParameter {
    return new CloseEmptyAccountServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: CloseEmptyAccountServerParameter | PlainMessage<CloseEmptyAccountServerParameter> | undefined, b: CloseEmptyAccountServerParameter | PlainMessage<CloseEmptyAccountServerParameter> | undefined): boolean {
    return proto3.util.equals(CloseEmptyAccountServerParameter, a, b);
  }
}

/**
 * There are no action-specific server parameters
 *
 * @generated from message code.transaction.v2.CloseDormantAccountServerParameter
 */
export class CloseDormantAccountServerParameter extends Message<CloseDormantAccountServerParameter> {
  constructor(data?: PartialMessage<CloseDormantAccountServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CloseDormantAccountServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloseDormantAccountServerParameter {
    return new CloseDormantAccountServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloseDormantAccountServerParameter {
    return new CloseDormantAccountServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloseDormantAccountServerParameter {
    return new CloseDormantAccountServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: CloseDormantAccountServerParameter | PlainMessage<CloseDormantAccountServerParameter> | undefined, b: CloseDormantAccountServerParameter | PlainMessage<CloseDormantAccountServerParameter> | undefined): boolean {
    return proto3.util.equals(CloseDormantAccountServerParameter, a, b);
  }
}

/**
 * There are no action-specific server parameters
 *
 * @generated from message code.transaction.v2.NoPrivacyTransferServerParameter
 */
export class NoPrivacyTransferServerParameter extends Message<NoPrivacyTransferServerParameter> {
  constructor(data?: PartialMessage<NoPrivacyTransferServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyTransferServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyTransferServerParameter | PlainMessage<NoPrivacyTransferServerParameter> | undefined, b: NoPrivacyTransferServerParameter | PlainMessage<NoPrivacyTransferServerParameter> | undefined): boolean {
    return proto3.util.equals(NoPrivacyTransferServerParameter, a, b);
  }
}

/**
 * There are no action-specific server parameters
 *
 * @generated from message code.transaction.v2.NoPrivacyWithdrawServerParameter
 */
export class NoPrivacyWithdrawServerParameter extends Message<NoPrivacyWithdrawServerParameter> {
  constructor(data?: PartialMessage<NoPrivacyWithdrawServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyWithdrawServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyWithdrawServerParameter | PlainMessage<NoPrivacyWithdrawServerParameter> | undefined, b: NoPrivacyWithdrawServerParameter | PlainMessage<NoPrivacyWithdrawServerParameter> | undefined): boolean {
    return proto3.util.equals(NoPrivacyWithdrawServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.TemporaryPrivacyTransferServerParameter
 */
export class TemporaryPrivacyTransferServerParameter extends Message<TemporaryPrivacyTransferServerParameter> {
  /**
   * The treasury that will be used to split payments and provide a level of privacy
   *
   * @generated from field: code.common.v1.SolanaAccountId treasury = 1;
   */
  treasury?: SolanaAccountId;

  /**
   * A recent root server observed from the treasury
   *
   * @generated from field: code.common.v1.Hash recent_root = 2;
   */
  recentRoot?: Hash;

  constructor(data?: PartialMessage<TemporaryPrivacyTransferServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.TemporaryPrivacyTransferServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "treasury", kind: "message", T: SolanaAccountId },
    { no: 2, name: "recent_root", kind: "message", T: Hash },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TemporaryPrivacyTransferServerParameter {
    return new TemporaryPrivacyTransferServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TemporaryPrivacyTransferServerParameter {
    return new TemporaryPrivacyTransferServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TemporaryPrivacyTransferServerParameter {
    return new TemporaryPrivacyTransferServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: TemporaryPrivacyTransferServerParameter | PlainMessage<TemporaryPrivacyTransferServerParameter> | undefined, b: TemporaryPrivacyTransferServerParameter | PlainMessage<TemporaryPrivacyTransferServerParameter> | undefined): boolean {
    return proto3.util.equals(TemporaryPrivacyTransferServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.TemporaryPrivacyExchangeServerParameter
 */
export class TemporaryPrivacyExchangeServerParameter extends Message<TemporaryPrivacyExchangeServerParameter> {
  /**
   * The treasury that will be used to split payments and provide a level of privacy
   *
   * @generated from field: code.common.v1.SolanaAccountId treasury = 1;
   */
  treasury?: SolanaAccountId;

  /**
   * A recent root server observed from the treasury
   *
   * @generated from field: code.common.v1.Hash recent_root = 2;
   */
  recentRoot?: Hash;

  constructor(data?: PartialMessage<TemporaryPrivacyExchangeServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.TemporaryPrivacyExchangeServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "treasury", kind: "message", T: SolanaAccountId },
    { no: 2, name: "recent_root", kind: "message", T: Hash },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TemporaryPrivacyExchangeServerParameter {
    return new TemporaryPrivacyExchangeServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TemporaryPrivacyExchangeServerParameter {
    return new TemporaryPrivacyExchangeServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TemporaryPrivacyExchangeServerParameter {
    return new TemporaryPrivacyExchangeServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: TemporaryPrivacyExchangeServerParameter | PlainMessage<TemporaryPrivacyExchangeServerParameter> | undefined, b: TemporaryPrivacyExchangeServerParameter | PlainMessage<TemporaryPrivacyExchangeServerParameter> | undefined): boolean {
    return proto3.util.equals(TemporaryPrivacyExchangeServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.PermanentPrivacyUpgradeServerParameter
 */
export class PermanentPrivacyUpgradeServerParameter extends Message<PermanentPrivacyUpgradeServerParameter> {
  /**
   * The new commitment that is being paid
   *
   * @generated from field: code.common.v1.SolanaAccountId new_commitment = 1;
   */
  newCommitment?: SolanaAccountId;

  /**
   * The new commitment account's transcript. This is purely needed by client
   * to validate merkle_root with commitment PDA logic.
   *
   * @generated from field: code.common.v1.Hash new_commitment_transcript = 2;
   */
  newCommitmentTranscript?: Hash;

  /**
   * The new commitment account's destination. This is purely needed by client
   * to validate merkle_root with commitment PDA logic.
   *
   * @generated from field: code.common.v1.SolanaAccountId new_commitment_destination = 3;
   */
  newCommitmentDestination?: SolanaAccountId;

  /**
   * The new commitment account's payment amount. This is purely needed by client
   * to validate merkle_root with commitment PDA logic.
   *
   * @generated from field: uint64 new_commitment_amount = 4;
   */
  newCommitmentAmount = protoInt64.zero;

  /**
   * The merkle root, which was the recent root used in the new commitment account
   *
   * @generated from field: code.common.v1.Hash merkle_root = 5;
   */
  merkleRoot?: Hash;

  /**
   * The merkle proof that validates the original commitment occurred prior to
   * the new commitment server is asking client to pay
   *
   * @generated from field: repeated code.common.v1.Hash merkle_proof = 6;
   */
  merkleProof: Hash[] = [];

  constructor(data?: PartialMessage<PermanentPrivacyUpgradeServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.PermanentPrivacyUpgradeServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "new_commitment", kind: "message", T: SolanaAccountId },
    { no: 2, name: "new_commitment_transcript", kind: "message", T: Hash },
    { no: 3, name: "new_commitment_destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "new_commitment_amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "merkle_root", kind: "message", T: Hash },
    { no: 6, name: "merkle_proof", kind: "message", T: Hash, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PermanentPrivacyUpgradeServerParameter {
    return new PermanentPrivacyUpgradeServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PermanentPrivacyUpgradeServerParameter {
    return new PermanentPrivacyUpgradeServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PermanentPrivacyUpgradeServerParameter {
    return new PermanentPrivacyUpgradeServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: PermanentPrivacyUpgradeServerParameter | PlainMessage<PermanentPrivacyUpgradeServerParameter> | undefined, b: PermanentPrivacyUpgradeServerParameter | PlainMessage<PermanentPrivacyUpgradeServerParameter> | undefined): boolean {
    return proto3.util.equals(PermanentPrivacyUpgradeServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.FeePaymentServerParameter
 */
export class FeePaymentServerParameter extends Message<FeePaymentServerParameter> {
  /**
   * The destination account where the fee payment should be sent.
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  constructor(data?: PartialMessage<FeePaymentServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.FeePaymentServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: FeePaymentServerParameter | PlainMessage<FeePaymentServerParameter> | undefined, b: FeePaymentServerParameter | PlainMessage<FeePaymentServerParameter> | undefined): boolean {
    return proto3.util.equals(FeePaymentServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ErrorDetails
 */
export class ErrorDetails extends Message<ErrorDetails> {
  /**
   * @generated from oneof code.transaction.v2.ErrorDetails.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.ReasonStringErrorDetails reason_string = 1;
     */
    value: ReasonStringErrorDetails;
    case: "reasonString";
  } | {
    /**
     * @generated from field: code.transaction.v2.InvalidSignatureErrorDetails invalid_signature = 2;
     */
    value: InvalidSignatureErrorDetails;
    case: "invalidSignature";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason_string", kind: "message", T: ReasonStringErrorDetails, oneof: "type" },
    { no: 2, name: "invalid_signature", kind: "message", T: InvalidSignatureErrorDetails, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorDetails {
    return new ErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorDetails {
    return new ErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorDetails {
    return new ErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorDetails | PlainMessage<ErrorDetails> | undefined, b: ErrorDetails | PlainMessage<ErrorDetails> | undefined): boolean {
    return proto3.util.equals(ErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ReasonStringErrorDetails
 */
export class ReasonStringErrorDetails extends Message<ReasonStringErrorDetails> {
  /**
   * Human readable string indicating the failure.
   *
   * @generated from field: string reason = 1;
   */
  reason = "";

  constructor(data?: PartialMessage<ReasonStringErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ReasonStringErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ReasonStringErrorDetails | PlainMessage<ReasonStringErrorDetails> | undefined, b: ReasonStringErrorDetails | PlainMessage<ReasonStringErrorDetails> | undefined): boolean {
    return proto3.util.equals(ReasonStringErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.InvalidSignatureErrorDetails
 */
export class InvalidSignatureErrorDetails extends Message<InvalidSignatureErrorDetails> {
  /**
   * The action whose signature mismatched 
   *
   * @generated from field: uint32 action_id = 1;
   */
  actionId = 0;

  /**
   * The transaction the server expected to have signed.
   *
   * @generated from field: code.common.v1.Transaction expected_transaction = 2;
   */
  expectedTransaction?: Transaction;

  /**
   * The signature that was provided by the client.
   *
   * @generated from field: code.common.v1.Signature provided_signature = 3;
   */
  providedSignature?: Signature;

  constructor(data?: PartialMessage<InvalidSignatureErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.InvalidSignatureErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "expected_transaction", kind: "message", T: Transaction },
    { no: 3, name: "provided_signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: InvalidSignatureErrorDetails | PlainMessage<InvalidSignatureErrorDetails> | undefined, b: InvalidSignatureErrorDetails | PlainMessage<InvalidSignatureErrorDetails> | undefined): boolean {
    return proto3.util.equals(InvalidSignatureErrorDetails, a, b);
  }
}

/**
 * UpgradeableIntent is an intent whose actions can be upgraded.
 *
 * @generated from message code.transaction.v2.UpgradeableIntent
 */
export class UpgradeableIntent extends Message<UpgradeableIntent> {
  /**
   * The intent ID
   *
   * @generated from field: code.common.v1.IntentId id = 1;
   */
  id?: IntentId;

  /**
   * The set of private actions that can be upgraded
   *
   * @generated from field: repeated code.transaction.v2.UpgradeableIntent.UpgradeablePrivateAction actions = 2;
   */
  actions: UpgradeableIntent_UpgradeablePrivateAction[] = [];

  constructor(data?: PartialMessage<UpgradeableIntent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.UpgradeableIntent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: IntentId },
    { no: 2, name: "actions", kind: "message", T: UpgradeableIntent_UpgradeablePrivateAction, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradeableIntent {
    return new UpgradeableIntent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradeableIntent {
    return new UpgradeableIntent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradeableIntent {
    return new UpgradeableIntent().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradeableIntent | PlainMessage<UpgradeableIntent> | undefined, b: UpgradeableIntent | PlainMessage<UpgradeableIntent> | undefined): boolean {
    return proto3.util.equals(UpgradeableIntent, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.UpgradeableIntent.UpgradeablePrivateAction
 */
export class UpgradeableIntent_UpgradeablePrivateAction extends Message<UpgradeableIntent_UpgradeablePrivateAction> {
  /**
   * The transaction blob that was signed by the client. Clients *MUST* use
   * the source and destination account in the timelock::TransferWithAuthority
   * instruction to validate all fields provided by server by locally computing
   * the expected addresses.
   *
   * @generated from field: code.common.v1.Transaction transaction_blob = 1;
   */
  transactionBlob?: Transaction;

  /**
   * The client's signature for the transaction. Clients MUST use this to
   * locally validate the transaction blob provided by server.
   *
   * @generated from field: code.common.v1.Signature client_signature = 2;
   */
  clientSignature?: Signature;

  /**
   * The action ID of this transaction
   *
   * @generated from field: uint32 action_id = 3;
   */
  actionId = 0;

  /**
   * The source account's type, which hints how to efficiently derive source
   *
   * @generated from field: code.common.v1.AccountType source_account_type = 4;
   */
  sourceAccountType = AccountType.UNKNOWN;

  /**
   * The source account's derivation index, which hints how to efficiently derive source
   *
   * @generated from field: uint64 source_derivation_index = 5;
   */
  sourceDerivationIndex = protoInt64.zero;

  /**
   * The original destination account that was paid by the treasury
   *
   * @generated from field: code.common.v1.SolanaAccountId original_destination = 6;
   */
  originalDestination?: SolanaAccountId;

  /**
   * The original quark amount for the action
   *
   * @generated from field: uint64 original_amount = 7;
   */
  originalAmount = protoInt64.zero;

  /**
   * The treasury used for this the private action
   *
   * @generated from field: code.common.v1.SolanaAccountId treasury = 8;
   */
  treasury?: SolanaAccountId;

  /**
   * The recent root observed at the time of intent creation for this private action
   *
   * @generated from field: code.common.v1.Hash recent_root = 9;
   */
  recentRoot?: Hash;

  constructor(data?: PartialMessage<UpgradeableIntent_UpgradeablePrivateAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.UpgradeableIntent.UpgradeablePrivateAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transaction_blob", kind: "message", T: Transaction },
    { no: 2, name: "client_signature", kind: "message", T: Signature },
    { no: 3, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "source_account_type", kind: "enum", T: proto3.getEnumType(AccountType) },
    { no: 5, name: "source_derivation_index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "original_destination", kind: "message", T: SolanaAccountId },
    { no: 7, name: "original_amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "treasury", kind: "message", T: SolanaAccountId },
    { no: 9, name: "recent_root", kind: "message", T: Hash },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradeableIntent_UpgradeablePrivateAction {
    return new UpgradeableIntent_UpgradeablePrivateAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradeableIntent_UpgradeablePrivateAction {
    return new UpgradeableIntent_UpgradeablePrivateAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradeableIntent_UpgradeablePrivateAction {
    return new UpgradeableIntent_UpgradeablePrivateAction().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradeableIntent_UpgradeablePrivateAction | PlainMessage<UpgradeableIntent_UpgradeablePrivateAction> | undefined, b: UpgradeableIntent_UpgradeablePrivateAction | PlainMessage<UpgradeableIntent_UpgradeablePrivateAction> | undefined): boolean {
    return proto3.util.equals(UpgradeableIntent_UpgradeablePrivateAction, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.PaymentHistoryItem
 */
export class PaymentHistoryItem extends Message<PaymentHistoryItem> {
  /**
   * The cursor position of this item.
   *
   * @generated from field: code.transaction.v2.Cursor cursor = 1;
   */
  cursor?: Cursor;

  /**
   * Exchange data related to the payment
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 2;
   */
  exchangeData?: ExchangeData;

  /**
   * Is this payment a send or receive?
   *
   * @generated from field: code.transaction.v2.PaymentHistoryItem.PaymentType payment_type = 3;
   */
  paymentType = PaymentHistoryItem_PaymentType.UNKNOWN;

  /**
   * If the payment was a SEND, was it a withdraw?
   *
   * @generated from field: bool is_withdraw = 4;
   */
  isWithdraw = false;

  /**
   * If the payment was a RECEIVE, was it a deposit?
   *
   * @generated from field: bool is_deposit = 5;
   */
  isDeposit = false;

  /**
   * The timestamp of the payment
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 6;
   */
  timestamp?: Timestamp;

  /**
   * Was the payment involved in a remote send?
   *
   * @generated from field: bool is_remote_send = 7;
   */
  isRemoteSend = false;

  /**
   * If payment_type is RECEIVE and is_remote_send is true, was the funds being
   * returned back to the issuer?
   *
   * @generated from field: bool is_returned = 8;
   */
  isReturned = false;

  /**
   * If payment_type is RECEIVE, is this receive an airdrop part of a reward, incentive, etc.?
   *
   * @generated from field: bool is_airdrop = 9;
   */
  isAirdrop = false;

  /**
   * If is_airdrop is true, the type of airdrop received.
   *
   * @generated from field: code.transaction.v2.AirdropType airdrop_type = 10;
   */
  airdropType = AirdropType.UNKNOWN;

  /**
   * Is this a micro payment? 
   *
   * @generated from field: bool is_micro_payment = 11;
   */
  isMicroPayment = false;

  /**
   * The intent ID associated with this history item
   *
   * @generated from field: code.common.v1.IntentId intent_id = 12;
   */
  intentId?: IntentId;

  constructor(data?: PartialMessage<PaymentHistoryItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.PaymentHistoryItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cursor", kind: "message", T: Cursor },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeData },
    { no: 3, name: "payment_type", kind: "enum", T: proto3.getEnumType(PaymentHistoryItem_PaymentType) },
    { no: 4, name: "is_withdraw", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "is_deposit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "timestamp", kind: "message", T: Timestamp },
    { no: 7, name: "is_remote_send", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "is_returned", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "is_airdrop", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "airdrop_type", kind: "enum", T: proto3.getEnumType(AirdropType) },
    { no: 11, name: "is_micro_payment", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "intent_id", kind: "message", T: IntentId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentHistoryItem {
    return new PaymentHistoryItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentHistoryItem {
    return new PaymentHistoryItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentHistoryItem {
    return new PaymentHistoryItem().fromJsonString(jsonString, options);
  }

  static equals(a: PaymentHistoryItem | PlainMessage<PaymentHistoryItem> | undefined, b: PaymentHistoryItem | PlainMessage<PaymentHistoryItem> | undefined): boolean {
    return proto3.util.equals(PaymentHistoryItem, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.PaymentHistoryItem.PaymentType
 */
export enum PaymentHistoryItem_PaymentType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: SEND = 1;
   */
  SEND = 1,

  /**
   * @generated from enum value: RECEIVE = 2;
   */
  RECEIVE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(PaymentHistoryItem_PaymentType)
proto3.util.setEnumType(PaymentHistoryItem_PaymentType, "code.transaction.v2.PaymentHistoryItem.PaymentType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "SEND" },
  { no: 2, name: "RECEIVE" },
]);

/**
 * ExchangeData defines an amount of Kin with currency exchange data
 *
 * @generated from message code.transaction.v2.ExchangeData
 */
export class ExchangeData extends Message<ExchangeData> {
  /**
   * ISO 4217 alpha-3 currency code.
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The agreed upon exchange rate. This might not be the same as the
   * actual exchange rate at the time of intent or fund transfer.
   *
   * @generated from field: double exchange_rate = 2;
   */
  exchangeRate = 0;

  /**
   * The agreed upon transfer amount in the currency the payment was made
   * in.
   *
   * @generated from field: double native_amount = 3;
   */
  nativeAmount = 0;

  /**
   * The exact amount of quarks to send. This will be used as the source of
   * truth for validating transaction transfer amounts.
   *
   * @generated from field: uint64 quarks = 4;
   */
  quarks = protoInt64.zero;

  constructor(data?: PartialMessage<ExchangeData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ExchangeData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "exchange_rate", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeData {
    return new ExchangeData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeData {
    return new ExchangeData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeData {
    return new ExchangeData().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeData | PlainMessage<ExchangeData> | undefined, b: ExchangeData | PlainMessage<ExchangeData> | undefined): boolean {
    return proto3.util.equals(ExchangeData, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ExchangeDataWithoutRate
 */
export class ExchangeDataWithoutRate extends Message<ExchangeDataWithoutRate> {
  /**
   * ISO 4217 alpha-3 currency code.
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The agreed upon transfer amount in the currency the payment was made
   * in.
   *
   * @generated from field: double native_amount = 2;
   */
  nativeAmount = 0;

  constructor(data?: PartialMessage<ExchangeDataWithoutRate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ExchangeDataWithoutRate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeDataWithoutRate | PlainMessage<ExchangeDataWithoutRate> | undefined, b: ExchangeDataWithoutRate | PlainMessage<ExchangeDataWithoutRate> | undefined): boolean {
    return proto3.util.equals(ExchangeDataWithoutRate, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.RemainingSendLimit
 */
export class RemainingSendLimit extends Message<RemainingSendLimit> {
  /**
   * Remaining limit to apply on the next transaction
   *
   * @generated from field: float next_transaction = 1;
   */
  nextTransaction = 0;

  constructor(data?: PartialMessage<RemainingSendLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.RemainingSendLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemainingSendLimit {
    return new RemainingSendLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemainingSendLimit {
    return new RemainingSendLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemainingSendLimit {
    return new RemainingSendLimit().fromJsonString(jsonString, options);
  }

  static equals(a: RemainingSendLimit | PlainMessage<RemainingSendLimit> | undefined, b: RemainingSendLimit | PlainMessage<RemainingSendLimit> | undefined): boolean {
    return proto3.util.equals(RemainingSendLimit, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.DepositLimit
 */
export class DepositLimit extends Message<DepositLimit> {
  /**
   * Maximum quarks that may be deposited at any time. Server will guarantee
   * this threshold will be below enforced dollar value limits, while also
   * ensuring sufficient funds are available for a full organizer that supports
   * max payment sends. Total dollar value limits may be spread across many deposits.
   *
   * @generated from field: uint64 max_quarks = 1;
   */
  maxQuarks = protoInt64.zero;

  constructor(data?: PartialMessage<DepositLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.DepositLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DepositLimit {
    return new DepositLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DepositLimit {
    return new DepositLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DepositLimit {
    return new DepositLimit().fromJsonString(jsonString, options);
  }

  static equals(a: DepositLimit | PlainMessage<DepositLimit> | undefined, b: DepositLimit | PlainMessage<DepositLimit> | undefined): boolean {
    return proto3.util.equals(DepositLimit, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.MicroPaymentLimit
 */
export class MicroPaymentLimit extends Message<MicroPaymentLimit> {
  /**
   * Maximum native amount that can be applied per micro payment transaction
   *
   * @generated from field: float max_per_transaction = 1;
   */
  maxPerTransaction = 0;

  /**
   * Minimum native amount that can be applied per micro payment transaction
   *
   * @generated from field: float min_per_transaction = 2;
   */
  minPerTransaction = 0;

  constructor(data?: PartialMessage<MicroPaymentLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.MicroPaymentLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_per_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "min_per_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MicroPaymentLimit {
    return new MicroPaymentLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MicroPaymentLimit {
    return new MicroPaymentLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MicroPaymentLimit {
    return new MicroPaymentLimit().fromJsonString(jsonString, options);
  }

  static equals(a: MicroPaymentLimit | PlainMessage<MicroPaymentLimit> | undefined, b: MicroPaymentLimit | PlainMessage<MicroPaymentLimit> | undefined): boolean {
    return proto3.util.equals(MicroPaymentLimit, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.Cursor
 */
export class Cursor extends Message<Cursor> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Cursor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.Cursor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cursor {
    return new Cursor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJsonString(jsonString, options);
  }

  static equals(a: Cursor | PlainMessage<Cursor> | undefined, b: Cursor | PlainMessage<Cursor> | undefined): boolean {
    return proto3.util.equals(Cursor, a, b);
  }
}

