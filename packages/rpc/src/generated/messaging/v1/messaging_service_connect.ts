// @generated by protoc-gen-connect-es v0.13.0 with parameter "target=ts"
// @generated from file messaging/v1/messaging_service.proto (package code.messaging.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { AckMessagesRequest, AckMesssagesResponse, OpenMessageStreamRequest, OpenMessageStreamResponse, OpenMessageStreamWithKeepAliveRequest, OpenMessageStreamWithKeepAliveResponse, PollMessagesRequest, PollMessagesResponse, SendMessageRequest, SendMessageResponse } from "./messaging_service_pb";
import { MethodKind } from "@bufbuild/protobuf";

/**
 * @generated from service code.messaging.v1.Messaging
 */
export const Messaging = {
  typeName: "code.messaging.v1.Messaging",
  methods: {
    /**
     * OpenMessageStream opens a stream of messages. Messages are routed using the
     * public key of a rendezvous keypair derived by both the sender and the
     * recipient of the messages. The sender may be a client or server.
     *
     * Messages are expected to be acked once they have been processed by the client.
     * Ack'd messages will no longer be delivered on future OpenMessageStream calls,
     * and are eligible for deletion from the service. Clients should, however, handle
     * duplicate delivery of messages.
     *
     * For grabbing a bill, the expected flow is as follows:
     *   1. The payment sender creates a cash scan code
     *   2. The payment sender calls OpenMessageStream on the rendezvous public key, which is
     *      derived by using sha256(scan payload) as the keypair seed.
     *   3. The payment recipient scans the code and uses SendMessage to send their account ID
     *      back to the sender via the rendezvous public key.
     *   4. The payment sender receives the message, submits the intent, and closes the stream.
     *
     * For receiving a bill of requested value, the expected flow is as follows:
     *   1. The payment recipient uses SendMessage to send their account ID and payment amount to
     *      the sender via the rendezvous public key, which is derived by using sha256(scan payload)
     *      as the keypair seed.
     *   2. The payment recipient calls OpenMessageStream on the rendezvous public key to listen
     *      for status messages generated by client/server. It must ignore the original message it sent
     *      as part of step 1.
     *   3. The payment recipient creates a payment request scan code
     *   4. The payment sender calls PollMessages on the rendezvous public key. This is ok because
     *      we know the message exists per step 1, and doesn't actually incur a long poll. This is a
     *      required hack because we don't have the infrastructure in place to allow multiple listens
     *      on the same stream, and the recipient needs real-time status updates.
     *   5. The payment sender receives the message (any status messages are ignored), and submits the
     *      intent.
     *   6. The payment recipient observes status message (eg. IntentSubmitted, ClientRejectedPayment,
     *      WebhookCalled) for payment state.
     *   7. The payment recipient closes the stream once the payment hits a terminal state, or times out.
     *
     * For logging in, the expected flow is as follows:
     *   1. The third party uses SendMessage to send their login challenge to the user via the rendezvous
     *      public key, which is derived by using sha256(scan payload) as the keypair seed.
     *   2. The third party calls OpenMessageStream on the rendezvous public key to listen for status
     *      messages generated by server. It must ignore the original message it sent as part of step 1.
     *   3. The third party creates a login scan code
     *   4. The user logging in calls PollMessages on the rendezvous public key. This is ok because
     *      we know the message exists per step 1, and doesn't actually incur a long poll. This is a
     *      required hack because we don't have the infrastructure in place to allow multiple listens
     *      on the same stream, and the recipient needs real-time status updates.
     *   5. The user logging in receives the message (any status messages are ignored), verifies it,
     *      then submits a login attempt.
     *   6. The third party observes status message (eg. IntentSubmitted, ClientRejectedLogin,
     *      WebhookCalled) for login state.
     *   7. The third party closes the stream once the login hits a terminal state, or times out.
     *
     * @generated from rpc code.messaging.v1.Messaging.OpenMessageStream
     */
    openMessageStream: {
      name: "OpenMessageStream",
      I: OpenMessageStreamRequest,
      O: OpenMessageStreamResponse,
      kind: MethodKind.ServerStreaming,
    },
    /**
     * OpenMessageStreamWithKeepAlive is like OpenMessageStream, but enables a ping/pong
     * keepalive to determine the health of the stream at both the client and server.
     *
     * The keepalive protocol is as follows:
     *   1. Client initiates a stream by sending an OpenMessageStreamRequest.
     *   2. Upon stream initialization, server begins the keepalive protocol.
     *   3. Server sends a ping to the client.
     *   4. Client responds with a pong as fast as possible, making note of
     *      the delay for when to expect the next ping.
     *   5. Steps 3 and 4 are repeated until the stream is explicitly terminated
     *      or is deemed to be unhealthy.
     *
     * Client notes:
     * * Client should be careful to process messages async, so any responses to pings are
     *   not delayed.
     * * Clients should implement a reasonable backoff strategy upon continued timeout failures.
     * * Clients that abuse pong messages may have their streams terminated by server.
     *
     * At any point in the stream, server will respond with messages in real time as
     * they are observed. Messages sent over the stream should not affect the ping/pong
     * protocol timings. Individual protocols for payment flows remain the same, and are
     * documented in OpenMessageStream.
     *
     * Note: This API will enforce OpenMessageStreamRequest.signature is set as part of migration
     *       to this newer protocol
     *
     * @generated from rpc code.messaging.v1.Messaging.OpenMessageStreamWithKeepAlive
     */
    openMessageStreamWithKeepAlive: {
      name: "OpenMessageStreamWithKeepAlive",
      I: OpenMessageStreamWithKeepAliveRequest,
      O: OpenMessageStreamWithKeepAliveResponse,
      kind: MethodKind.BiDiStreaming,
    },
    /**
     * PollMessages is like OpenMessageStream, but uses a polling flow for receiving
     * messages. Updates are not real-time and depedent on the polling interval.
     * This RPC supports all message types.
     *
     * This is a temporary RPC until OpenMessageStream can be built out generically on
     * both client and server, while supporting things like multiple listeners.
     *
     * @generated from rpc code.messaging.v1.Messaging.PollMessages
     */
    pollMessages: {
      name: "PollMessages",
      I: PollMessagesRequest,
      O: PollMessagesResponse,
      kind: MethodKind.Unary,
    },
    /**
     * AckMessages acks one or more messages that have been successfully delivered to
     * the client.
     *
     * @generated from rpc code.messaging.v1.Messaging.AckMessages
     */
    ackMessages: {
      name: "AckMessages",
      I: AckMessagesRequest,
      O: AckMesssagesResponse,
      kind: MethodKind.Unary,
    },
    /**
     * SendMessage sends a message.
     *
     * @generated from rpc code.messaging.v1.Messaging.SendMessage
     */
    sendMessage: {
      name: "SendMessage",
      I: SendMessageRequest,
      O: SendMessageResponse,
      kind: MethodKind.Unary,
    },
  }
} as const;

