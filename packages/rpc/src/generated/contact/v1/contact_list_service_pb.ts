// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file contact/v1/contact_list_service.proto (package code.contact.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { DataContainerId, PhoneNumber, Signature, SolanaAccountId } from "../../common/v1/model_pb";

/**
 * @generated from message code.contact.v1.AddContactsRequest
 */
export class AddContactsRequest extends Message<AddContactsRequest> {
  /**
   * The public key of the owner account that signed this request message.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The signature is of serialize(AddContactsRequest) without this field set
   * using the private key of owner_account_id. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * The data container for the copy of the contact list being added to.
   *
   * @generated from field: code.common.v1.DataContainerId container_id = 3;
   */
  containerId?: DataContainerId;

  /**
   * The set of contacts to add to the contact list
   *
   * @generated from field: repeated code.common.v1.PhoneNumber contacts = 4;
   */
  contacts: PhoneNumber[] = [];

  constructor(data?: PartialMessage<AddContactsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.contact.v1.AddContactsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "container_id", kind: "message", T: DataContainerId },
    { no: 4, name: "contacts", kind: "message", T: PhoneNumber, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddContactsRequest {
    return new AddContactsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddContactsRequest {
    return new AddContactsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddContactsRequest {
    return new AddContactsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AddContactsRequest | PlainMessage<AddContactsRequest> | undefined, b: AddContactsRequest | PlainMessage<AddContactsRequest> | undefined): boolean {
    return proto3.util.equals(AddContactsRequest, a, b);
  }
}

/**
 * @generated from message code.contact.v1.AddContactsResponse
 */
export class AddContactsResponse extends Message<AddContactsResponse> {
  /**
   * @generated from field: code.contact.v1.AddContactsResponse.Result result = 1;
   */
  result = AddContactsResponse_Result.OK;

  /**
   * The contacts' current status keyed by phone number. This is an optimization
   * so that clients can populate initial state without needing an extra network
   * call.
   *
   * @generated from field: map<string, code.contact.v1.ContactStatus> contact_status = 2;
   */
  contactStatus: { [key: string]: ContactStatus } = {};

  constructor(data?: PartialMessage<AddContactsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.contact.v1.AddContactsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(AddContactsResponse_Result) },
    { no: 2, name: "contact_status", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ContactStatus} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddContactsResponse {
    return new AddContactsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddContactsResponse {
    return new AddContactsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddContactsResponse {
    return new AddContactsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AddContactsResponse | PlainMessage<AddContactsResponse> | undefined, b: AddContactsResponse | PlainMessage<AddContactsResponse> | undefined): boolean {
    return proto3.util.equals(AddContactsResponse, a, b);
  }
}

/**
 * @generated from enum code.contact.v1.AddContactsResponse.Result
 */
export enum AddContactsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(AddContactsResponse_Result)
proto3.util.setEnumType(AddContactsResponse_Result, "code.contact.v1.AddContactsResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.contact.v1.RemoveContactsRequest
 */
export class RemoveContactsRequest extends Message<RemoveContactsRequest> {
  /**
   * The public key of the owner account that signed this request message.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The signature is of serialize(RemoveContactsRequest) without this field
   * set using the private key of owner_account_id. This provides an
   * authentication mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * The data container for the copy of the contact list being removed from.
   *
   * @generated from field: code.common.v1.DataContainerId container_id = 3;
   */
  containerId?: DataContainerId;

  /**
   * The set of contacts to remove from the contact list
   *
   * @generated from field: repeated code.common.v1.PhoneNumber contacts = 4;
   */
  contacts: PhoneNumber[] = [];

  constructor(data?: PartialMessage<RemoveContactsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.contact.v1.RemoveContactsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "container_id", kind: "message", T: DataContainerId },
    { no: 4, name: "contacts", kind: "message", T: PhoneNumber, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveContactsRequest {
    return new RemoveContactsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveContactsRequest {
    return new RemoveContactsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveContactsRequest {
    return new RemoveContactsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveContactsRequest | PlainMessage<RemoveContactsRequest> | undefined, b: RemoveContactsRequest | PlainMessage<RemoveContactsRequest> | undefined): boolean {
    return proto3.util.equals(RemoveContactsRequest, a, b);
  }
}

/**
 * @generated from message code.contact.v1.RemoveContactsResponse
 */
export class RemoveContactsResponse extends Message<RemoveContactsResponse> {
  /**
   * @generated from field: code.contact.v1.RemoveContactsResponse.Result result = 1;
   */
  result = RemoveContactsResponse_Result.OK;

  constructor(data?: PartialMessage<RemoveContactsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.contact.v1.RemoveContactsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(RemoveContactsResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveContactsResponse {
    return new RemoveContactsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveContactsResponse {
    return new RemoveContactsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveContactsResponse {
    return new RemoveContactsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveContactsResponse | PlainMessage<RemoveContactsResponse> | undefined, b: RemoveContactsResponse | PlainMessage<RemoveContactsResponse> | undefined): boolean {
    return proto3.util.equals(RemoveContactsResponse, a, b);
  }
}

/**
 * @generated from enum code.contact.v1.RemoveContactsResponse.Result
 */
export enum RemoveContactsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(RemoveContactsResponse_Result)
proto3.util.setEnumType(RemoveContactsResponse_Result, "code.contact.v1.RemoveContactsResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.contact.v1.GetContactsRequest
 */
export class GetContactsRequest extends Message<GetContactsRequest> {
  /**
   * The public key of the owner account that signed this request message.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The signature is of serialize(GetContactsRequest) without this field set
   * using the private key of owner_account_id. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * The data container for the copy of the contact list being fetched.
   *
   * @generated from field: code.common.v1.DataContainerId container_id = 3;
   */
  containerId?: DataContainerId;

  /**
   * The page token, which is retreived from a previous response, to get the next
   * set of contacts. The first page is returned when not set.
   *
   * @generated from field: code.contact.v1.PageToken page_token = 4;
   */
  pageToken?: PageToken;

  /**
   * Filter out contacts that have an association with Code. This includes users
   * that have both been invited and registered with the app.
   *
   * @generated from field: bool include_only_in_app_contacts = 5;
   */
  includeOnlyInAppContacts = false;

  constructor(data?: PartialMessage<GetContactsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.contact.v1.GetContactsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "container_id", kind: "message", T: DataContainerId },
    { no: 4, name: "page_token", kind: "message", T: PageToken },
    { no: 5, name: "include_only_in_app_contacts", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetContactsRequest {
    return new GetContactsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetContactsRequest {
    return new GetContactsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetContactsRequest {
    return new GetContactsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetContactsRequest | PlainMessage<GetContactsRequest> | undefined, b: GetContactsRequest | PlainMessage<GetContactsRequest> | undefined): boolean {
    return proto3.util.equals(GetContactsRequest, a, b);
  }
}

/**
 * @generated from message code.contact.v1.GetContactsResponse
 */
export class GetContactsResponse extends Message<GetContactsResponse> {
  /**
   * @generated from field: code.contact.v1.GetContactsResponse.Result result = 1;
   */
  result = GetContactsResponse_Result.OK;

  /**
   * A page of contacts
   *
   * @generated from field: repeated code.contact.v1.Contact contacts = 2;
   */
  contacts: Contact[] = [];

  /**
   * The page token to include in a subsequent request to get the next set of
   * contacts. This will not be set for the last response in the list of
   * pages.
   *
   * @generated from field: code.contact.v1.PageToken next_page_token = 3;
   */
  nextPageToken?: PageToken;

  constructor(data?: PartialMessage<GetContactsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.contact.v1.GetContactsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetContactsResponse_Result) },
    { no: 2, name: "contacts", kind: "message", T: Contact, repeated: true },
    { no: 3, name: "next_page_token", kind: "message", T: PageToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetContactsResponse {
    return new GetContactsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetContactsResponse {
    return new GetContactsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetContactsResponse {
    return new GetContactsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetContactsResponse | PlainMessage<GetContactsResponse> | undefined, b: GetContactsResponse | PlainMessage<GetContactsResponse> | undefined): boolean {
    return proto3.util.equals(GetContactsResponse, a, b);
  }
}

/**
 * @generated from enum code.contact.v1.GetContactsResponse.Result
 */
export enum GetContactsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(GetContactsResponse_Result)
proto3.util.setEnumType(GetContactsResponse_Result, "code.contact.v1.GetContactsResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.contact.v1.Contact
 */
export class Contact extends Message<Contact> {
  /**
   * The contact's phone number
   *
   * @generated from field: code.common.v1.PhoneNumber phone_number = 1;
   */
  phoneNumber?: PhoneNumber;

  /**
   * The contact's current status
   *
   * @generated from field: code.contact.v1.ContactStatus status = 2;
   */
  status?: ContactStatus;

  constructor(data?: PartialMessage<Contact>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.contact.v1.Contact";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phone_number", kind: "message", T: PhoneNumber },
    { no: 2, name: "status", kind: "message", T: ContactStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Contact {
    return new Contact().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Contact {
    return new Contact().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Contact {
    return new Contact().fromJsonString(jsonString, options);
  }

  static equals(a: Contact | PlainMessage<Contact> | undefined, b: Contact | PlainMessage<Contact> | undefined): boolean {
    return proto3.util.equals(Contact, a, b);
  }
}

/**
 * @generated from message code.contact.v1.ContactStatus
 */
export class ContactStatus extends Message<ContactStatus> {
  /**
   * Flag to indicate whether a user has registered with Code and used the app
   * at least once.
   *
   * @generated from field: bool is_registered = 1;
   */
  isRegistered = false;

  /**
   * Flag to indicate whether a user has been invited to Code.
   *
   * todo: This field will be deprecated after the invite phase is complete.
   *
   * @generated from field: bool is_invited = 2;
   */
  isInvited = false;

  /**
   * Flag to indicate whether a user's invitation to Code has been revoked.
   *
   * todo: This field will be deprecated after the invite phase is complete.
   *
   * @generated from field: bool is_invite_revoked = 3;
   */
  isInviteRevoked = false;

  constructor(data?: PartialMessage<ContactStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.contact.v1.ContactStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_registered", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "is_invited", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "is_invite_revoked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContactStatus {
    return new ContactStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContactStatus {
    return new ContactStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContactStatus {
    return new ContactStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ContactStatus | PlainMessage<ContactStatus> | undefined, b: ContactStatus | PlainMessage<ContactStatus> | undefined): boolean {
    return proto3.util.equals(ContactStatus, a, b);
  }
}

/**
 * @generated from message code.contact.v1.PageToken
 */
export class PageToken extends Message<PageToken> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<PageToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.contact.v1.PageToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PageToken {
    return new PageToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PageToken {
    return new PageToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PageToken {
    return new PageToken().fromJsonString(jsonString, options);
  }

  static equals(a: PageToken | PlainMessage<PageToken> | undefined, b: PageToken | PlainMessage<PageToken> | undefined): boolean {
    return proto3.util.equals(PageToken, a, b);
  }
}

