// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file user/v1/identity_service.proto (package code.user.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { DataContainerId, PhoneNumber, Signature, SolanaAccountId, UserId } from "../../common/v1/model_pb";
import { PhoneLinkingToken } from "../../phone/v1/phone_verification_service_pb";
import { AirdropType } from "../../transaction/v2/transaction_service_pb";

/**
 * @generated from message code.user.v1.LinkAccountRequest
 */
export class LinkAccountRequest extends Message<LinkAccountRequest> {
  /**
   * The public key of the owner account that will be linked to a user.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The signature is of serialize(LinkAccountRequest) without this field set
   * using the private key of owner_account_id. This validates that the client
   * actually owns the account.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * A one-time use token that identifies and authenticates the user.
   *
   * @generated from oneof code.user.v1.LinkAccountRequest.token
   */
  token: {
    /**
     * A token received after successfully verifying a phone number via a
     * SMS code using the phone verification service.
     *
     * @generated from field: code.phone.v1.PhoneLinkingToken phone = 3;
     */
    value: PhoneLinkingToken;
    case: "phone";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LinkAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.LinkAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "phone", kind: "message", T: PhoneLinkingToken, oneof: "token" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinkAccountRequest {
    return new LinkAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinkAccountRequest {
    return new LinkAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinkAccountRequest {
    return new LinkAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LinkAccountRequest | PlainMessage<LinkAccountRequest> | undefined, b: LinkAccountRequest | PlainMessage<LinkAccountRequest> | undefined): boolean {
    return proto3.util.equals(LinkAccountRequest, a, b);
  }
}

/**
 * @generated from message code.user.v1.LinkAccountResponse
 */
export class LinkAccountResponse extends Message<LinkAccountResponse> {
  /**
   * @generated from field: code.user.v1.LinkAccountResponse.Result result = 1;
   */
  result = LinkAccountResponse_Result.OK;

  /**
   * The user that was linked to the owner account
   *
   * @generated from field: code.user.v1.User user = 2;
   */
  user?: User;

  /**
   * The data container where the user can store a copy of their data
   *
   * @generated from field: code.common.v1.DataContainerId data_container_id = 3;
   */
  dataContainerId?: DataContainerId;

  /**
   * Metadata about the user based for the instance of their view
   *
   * @generated from oneof code.user.v1.LinkAccountResponse.metadata
   */
  metadata: {
    /**
     * Metadata that corresponds to a phone-based identifying feature.
     *
     * @generated from field: code.user.v1.PhoneMetadata phone = 5;
     */
    value: PhoneMetadata;
    case: "phone";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LinkAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.LinkAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(LinkAccountResponse_Result) },
    { no: 2, name: "user", kind: "message", T: User },
    { no: 3, name: "data_container_id", kind: "message", T: DataContainerId },
    { no: 5, name: "phone", kind: "message", T: PhoneMetadata, oneof: "metadata" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinkAccountResponse {
    return new LinkAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinkAccountResponse {
    return new LinkAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinkAccountResponse {
    return new LinkAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LinkAccountResponse | PlainMessage<LinkAccountResponse> | undefined, b: LinkAccountResponse | PlainMessage<LinkAccountResponse> | undefined): boolean {
    return proto3.util.equals(LinkAccountResponse, a, b);
  }
}

/**
 * @generated from enum code.user.v1.LinkAccountResponse.Result
 */
export enum LinkAccountResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The provided token is invalid. A token may be invalid for a number of
   * reasons including: it's already been used, has been modified by the
   * client or has expired.
   *
   * @generated from enum value: INVALID_TOKEN = 1;
   */
  INVALID_TOKEN = 1,

  /**
   * The client is rate limited (eg. by IP, user ID, etc). The client should
   * retry at a later time.
   *
   * @generated from enum value: RATE_LIMITED = 2;
   */
  RATE_LIMITED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LinkAccountResponse_Result)
proto3.util.setEnumType(LinkAccountResponse_Result, "code.user.v1.LinkAccountResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "INVALID_TOKEN" },
  { no: 2, name: "RATE_LIMITED" },
]);

/**
 * @generated from message code.user.v1.UnlinkAccountRequest
 */
export class UnlinkAccountRequest extends Message<UnlinkAccountRequest> {
  /**
   * The public key of the owner account that will be unliked.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The signature is of serialize(UnlinkAccountRequest) without this field set
   * using the private key of owner_account_id. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * @generated from oneof code.user.v1.UnlinkAccountRequest.identifying_feature
   */
  identifyingFeature: {
    /**
     * The phone number associated with the owner account. Remote send features
     * will be disabled on success.
     *
     * @generated from field: code.common.v1.PhoneNumber phone_number = 4;
     */
    value: PhoneNumber;
    case: "phoneNumber";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UnlinkAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.UnlinkAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 4, name: "phone_number", kind: "message", T: PhoneNumber, oneof: "identifying_feature" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnlinkAccountRequest {
    return new UnlinkAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnlinkAccountRequest {
    return new UnlinkAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnlinkAccountRequest {
    return new UnlinkAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UnlinkAccountRequest | PlainMessage<UnlinkAccountRequest> | undefined, b: UnlinkAccountRequest | PlainMessage<UnlinkAccountRequest> | undefined): boolean {
    return proto3.util.equals(UnlinkAccountRequest, a, b);
  }
}

/**
 * @generated from message code.user.v1.UnlinkAccountResponse
 */
export class UnlinkAccountResponse extends Message<UnlinkAccountResponse> {
  /**
   * @generated from field: code.user.v1.UnlinkAccountResponse.Result result = 1;
   */
  result = UnlinkAccountResponse_Result.OK;

  constructor(data?: PartialMessage<UnlinkAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.UnlinkAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(UnlinkAccountResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnlinkAccountResponse {
    return new UnlinkAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnlinkAccountResponse {
    return new UnlinkAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnlinkAccountResponse {
    return new UnlinkAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UnlinkAccountResponse | PlainMessage<UnlinkAccountResponse> | undefined, b: UnlinkAccountResponse | PlainMessage<UnlinkAccountResponse> | undefined): boolean {
    return proto3.util.equals(UnlinkAccountResponse, a, b);
  }
}

/**
 * @generated from enum code.user.v1.UnlinkAccountResponse.Result
 */
export enum UnlinkAccountResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The client attempted to unlink an owner account or identifying feature
   * that never had a valid association.
   *
   * @generated from enum value: NEVER_ASSOCIATED = 1;
   */
  NEVER_ASSOCIATED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(UnlinkAccountResponse_Result)
proto3.util.setEnumType(UnlinkAccountResponse_Result, "code.user.v1.UnlinkAccountResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NEVER_ASSOCIATED" },
]);

/**
 * @generated from message code.user.v1.GetUserRequest
 */
export class GetUserRequest extends Message<GetUserRequest> {
  /**
   * The public key of the owner account that signed this request message.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The signature is of serialize(GetUserRequest) without this field set
   * using the private key of owner_account_id. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * The user's indentifying feature, which maps to an instance of a view.
   *
   * @generated from oneof code.user.v1.GetUserRequest.identifying_feature
   */
  identifyingFeature: {
    /**
     * @generated from field: code.common.v1.PhoneNumber phone_number = 3;
     */
    value: PhoneNumber;
    case: "phoneNumber";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.GetUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "phone_number", kind: "message", T: PhoneNumber, oneof: "identifying_feature" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUserRequest {
    return new GetUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUserRequest {
    return new GetUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUserRequest {
    return new GetUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetUserRequest | PlainMessage<GetUserRequest> | undefined, b: GetUserRequest | PlainMessage<GetUserRequest> | undefined): boolean {
    return proto3.util.equals(GetUserRequest, a, b);
  }
}

/**
 * @generated from message code.user.v1.GetUserResponse
 */
export class GetUserResponse extends Message<GetUserResponse> {
  /**
   * @generated from field: code.user.v1.GetUserResponse.Result result = 1;
   */
  result = GetUserResponse_Result.OK;

  /**
   * The user associated with the identifier
   *
   * @generated from field: code.user.v1.User user = 2;
   */
  user?: User;

  /**
   * The data container where the user can store a copy of their data
   *
   * @generated from field: code.common.v1.DataContainerId data_container_id = 3;
   */
  dataContainerId?: DataContainerId;

  /**
   * Metadata about the user based for the instance of their view
   *
   * @generated from oneof code.user.v1.GetUserResponse.metadata
   */
  metadata: {
    /**
     * Metadata that corresponds to a phone-based identifying feature.
     *
     * @generated from field: code.user.v1.PhoneMetadata phone = 5;
     */
    value: PhoneMetadata;
    case: "phone";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Whether client beta flags are enabled for this user
   *
   * @generated from field: bool enable_beta_flags = 6;
   */
  enableBetaFlags = false;

  /**
   * Set of which airdrops the user is eligible to receive
   *
   * @generated from field: repeated code.transaction.v2.AirdropType eligible_airdrops = 7;
   */
  eligibleAirdrops: AirdropType[] = [];

  constructor(data?: PartialMessage<GetUserResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.GetUserResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetUserResponse_Result) },
    { no: 2, name: "user", kind: "message", T: User },
    { no: 3, name: "data_container_id", kind: "message", T: DataContainerId },
    { no: 5, name: "phone", kind: "message", T: PhoneMetadata, oneof: "metadata" },
    { no: 6, name: "enable_beta_flags", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "eligible_airdrops", kind: "enum", T: proto3.getEnumType(AirdropType), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUserResponse {
    return new GetUserResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUserResponse {
    return new GetUserResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUserResponse {
    return new GetUserResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetUserResponse | PlainMessage<GetUserResponse> | undefined, b: GetUserResponse | PlainMessage<GetUserResponse> | undefined): boolean {
    return proto3.util.equals(GetUserResponse, a, b);
  }
}

/**
 * @generated from enum code.user.v1.GetUserResponse.Result
 */
export enum GetUserResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The user doesn't exist
   *
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,

  /**
   * The user is no longer invited
   *
   * @generated from enum value: NOT_INVITED = 2;
   */
  NOT_INVITED = 2,

  /**
   * The user exists, but at least one of their timelock accounts is unlocked
   *
   * @generated from enum value: UNLOCKED_TIMELOCK_ACCOUNT = 3;
   */
  UNLOCKED_TIMELOCK_ACCOUNT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(GetUserResponse_Result)
proto3.util.setEnumType(GetUserResponse_Result, "code.user.v1.GetUserResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
  { no: 2, name: "NOT_INVITED" },
  { no: 3, name: "UNLOCKED_TIMELOCK_ACCOUNT" },
]);

/**
 * User is the highest order of a form of identity.
 *
 * @generated from message code.user.v1.User
 */
export class User extends Message<User> {
  /**
   * The user's ID
   *
   * @generated from field: code.common.v1.UserId id = 1;
   */
  id?: UserId;

  /**
   * The identifying features that are associated with the user
   *
   * @generated from field: code.user.v1.View view = 2;
   */
  view?: View;

  constructor(data?: PartialMessage<User>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.User";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: UserId },
    { no: 2, name: "view", kind: "message", T: View },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): User {
    return new User().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): User {
    return new User().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): User {
    return new User().fromJsonString(jsonString, options);
  }

  static equals(a: User | PlainMessage<User> | undefined, b: User | PlainMessage<User> | undefined): boolean {
    return proto3.util.equals(User, a, b);
  }
}

/**
 * View is a well-defined set of identifying features. It is contrained to having
 * exactly one feature set at a time, for now.
 *
 * @generated from message code.user.v1.View
 */
export class View extends Message<View> {
  /**
   * The phone number associated with a user.
   *
   * Note: This field is mandatory as of right now, since it's the only one
   *       supported to date.
   *
   * @generated from field: code.common.v1.PhoneNumber phone_number = 1;
   */
  phoneNumber?: PhoneNumber;

  constructor(data?: PartialMessage<View>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.View";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phone_number", kind: "message", T: PhoneNumber },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): View {
    return new View().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): View {
    return new View().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): View {
    return new View().fromJsonString(jsonString, options);
  }

  static equals(a: View | PlainMessage<View> | undefined, b: View | PlainMessage<View> | undefined): boolean {
    return proto3.util.equals(View, a, b);
  }
}

/**
 * @generated from message code.user.v1.PhoneMetadata
 */
export class PhoneMetadata extends Message<PhoneMetadata> {
  /**
   * State that determines whether a phone number is linked to the owner
   * account. A phone number is linked if we can treat it as an alias.
   * This is notably different from association, which answers the question
   * of whether the number was linked at any point in time.
   *
   * @generated from field: bool is_linked = 1;
   */
  isLinked = false;

  constructor(data?: PartialMessage<PhoneMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.PhoneMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_linked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PhoneMetadata {
    return new PhoneMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PhoneMetadata {
    return new PhoneMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PhoneMetadata {
    return new PhoneMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PhoneMetadata | PlainMessage<PhoneMetadata> | undefined, b: PhoneMetadata | PlainMessage<PhoneMetadata> | undefined): boolean {
    return proto3.util.equals(PhoneMetadata, a, b);
  }
}

