// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file user/v1/identity_service.proto (package code.user.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { DataContainerId, IntentId, Locale, PhoneNumber, Signature, SolanaAccountId, UserId } from "../../common/v1/model_pb";
import { PhoneLinkingToken } from "../../phone/v1/phone_verification_service_pb";
import { AirdropType } from "../../transaction/v2/transaction_service_pb";

/**
 * @generated from message code.user.v1.LinkAccountRequest
 */
export class LinkAccountRequest extends Message<LinkAccountRequest> {
  /**
   * The public key of the owner account that will be linked to a user.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The signature is of serialize(LinkAccountRequest) without this field set
   * using the private key of owner_account_id. This validates that the client
   * actually owns the account.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * A one-time use token that identifies and authenticates the user.
   *
   * @generated from oneof code.user.v1.LinkAccountRequest.token
   */
  token: {
    /**
     * A token received after successfully verifying a phone number via a
     * SMS code using the phone verification service.
     *
     * @generated from field: code.phone.v1.PhoneLinkingToken phone = 3;
     */
    value: PhoneLinkingToken;
    case: "phone";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LinkAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.LinkAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "phone", kind: "message", T: PhoneLinkingToken, oneof: "token" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinkAccountRequest {
    return new LinkAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinkAccountRequest {
    return new LinkAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinkAccountRequest {
    return new LinkAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LinkAccountRequest | PlainMessage<LinkAccountRequest> | undefined, b: LinkAccountRequest | PlainMessage<LinkAccountRequest> | undefined): boolean {
    return proto3.util.equals(LinkAccountRequest, a, b);
  }
}

/**
 * @generated from message code.user.v1.LinkAccountResponse
 */
export class LinkAccountResponse extends Message<LinkAccountResponse> {
  /**
   * @generated from field: code.user.v1.LinkAccountResponse.Result result = 1;
   */
  result = LinkAccountResponse_Result.OK;

  /**
   * The user that was linked to the owner account
   *
   * @generated from field: code.user.v1.User user = 2;
   */
  user?: User;

  /**
   * The data container where the user can store a copy of their data
   *
   * @generated from field: code.common.v1.DataContainerId data_container_id = 3;
   */
  dataContainerId?: DataContainerId;

  /**
   * Metadata about the user based for the instance of their view
   *
   * @generated from oneof code.user.v1.LinkAccountResponse.metadata
   */
  metadata: {
    /**
     * Metadata that corresponds to a phone-based identifying feature.
     *
     * @generated from field: code.user.v1.PhoneMetadata phone = 5;
     */
    value: PhoneMetadata;
    case: "phone";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LinkAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.LinkAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(LinkAccountResponse_Result) },
    { no: 2, name: "user", kind: "message", T: User },
    { no: 3, name: "data_container_id", kind: "message", T: DataContainerId },
    { no: 5, name: "phone", kind: "message", T: PhoneMetadata, oneof: "metadata" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinkAccountResponse {
    return new LinkAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinkAccountResponse {
    return new LinkAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinkAccountResponse {
    return new LinkAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LinkAccountResponse | PlainMessage<LinkAccountResponse> | undefined, b: LinkAccountResponse | PlainMessage<LinkAccountResponse> | undefined): boolean {
    return proto3.util.equals(LinkAccountResponse, a, b);
  }
}

/**
 * @generated from enum code.user.v1.LinkAccountResponse.Result
 */
export enum LinkAccountResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The provided token is invalid. A token may be invalid for a number of
   * reasons including: it's already been used, has been modified by the
   * client or has expired.
   *
   * @generated from enum value: INVALID_TOKEN = 1;
   */
  INVALID_TOKEN = 1,

  /**
   * The client is rate limited (eg. by IP, user ID, etc). The client should
   * retry at a later time.
   *
   * @generated from enum value: RATE_LIMITED = 2;
   */
  RATE_LIMITED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LinkAccountResponse_Result)
proto3.util.setEnumType(LinkAccountResponse_Result, "code.user.v1.LinkAccountResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "INVALID_TOKEN" },
  { no: 2, name: "RATE_LIMITED" },
]);

/**
 * @generated from message code.user.v1.UnlinkAccountRequest
 */
export class UnlinkAccountRequest extends Message<UnlinkAccountRequest> {
  /**
   * The public key of the owner account that will be unliked.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The signature is of serialize(UnlinkAccountRequest) without this field set
   * using the private key of owner_account_id. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * @generated from oneof code.user.v1.UnlinkAccountRequest.identifying_feature
   */
  identifyingFeature: {
    /**
     * The phone number associated with the owner account.
     *
     * @generated from field: code.common.v1.PhoneNumber phone_number = 4;
     */
    value: PhoneNumber;
    case: "phoneNumber";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UnlinkAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.UnlinkAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 4, name: "phone_number", kind: "message", T: PhoneNumber, oneof: "identifying_feature" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnlinkAccountRequest {
    return new UnlinkAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnlinkAccountRequest {
    return new UnlinkAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnlinkAccountRequest {
    return new UnlinkAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UnlinkAccountRequest | PlainMessage<UnlinkAccountRequest> | undefined, b: UnlinkAccountRequest | PlainMessage<UnlinkAccountRequest> | undefined): boolean {
    return proto3.util.equals(UnlinkAccountRequest, a, b);
  }
}

/**
 * @generated from message code.user.v1.UnlinkAccountResponse
 */
export class UnlinkAccountResponse extends Message<UnlinkAccountResponse> {
  /**
   * @generated from field: code.user.v1.UnlinkAccountResponse.Result result = 1;
   */
  result = UnlinkAccountResponse_Result.OK;

  constructor(data?: PartialMessage<UnlinkAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.UnlinkAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(UnlinkAccountResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnlinkAccountResponse {
    return new UnlinkAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnlinkAccountResponse {
    return new UnlinkAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnlinkAccountResponse {
    return new UnlinkAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UnlinkAccountResponse | PlainMessage<UnlinkAccountResponse> | undefined, b: UnlinkAccountResponse | PlainMessage<UnlinkAccountResponse> | undefined): boolean {
    return proto3.util.equals(UnlinkAccountResponse, a, b);
  }
}

/**
 * @generated from enum code.user.v1.UnlinkAccountResponse.Result
 */
export enum UnlinkAccountResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The client attempted to unlink an owner account or identifying feature
   * that never had a valid association.
   *
   * @generated from enum value: NEVER_ASSOCIATED = 1;
   */
  NEVER_ASSOCIATED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(UnlinkAccountResponse_Result)
proto3.util.setEnumType(UnlinkAccountResponse_Result, "code.user.v1.UnlinkAccountResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NEVER_ASSOCIATED" },
]);

/**
 * @generated from message code.user.v1.GetUserRequest
 */
export class GetUserRequest extends Message<GetUserRequest> {
  /**
   * The public key of the owner account that signed this request message.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The signature is of serialize(GetUserRequest) without this field set
   * using the private key of owner_account_id. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * The user's indentifying feature, which maps to an instance of a view.
   *
   * @generated from oneof code.user.v1.GetUserRequest.identifying_feature
   */
  identifyingFeature: {
    /**
     * @generated from field: code.common.v1.PhoneNumber phone_number = 3;
     */
    value: PhoneNumber;
    case: "phoneNumber";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.GetUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "phone_number", kind: "message", T: PhoneNumber, oneof: "identifying_feature" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUserRequest {
    return new GetUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUserRequest {
    return new GetUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUserRequest {
    return new GetUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetUserRequest | PlainMessage<GetUserRequest> | undefined, b: GetUserRequest | PlainMessage<GetUserRequest> | undefined): boolean {
    return proto3.util.equals(GetUserRequest, a, b);
  }
}

/**
 * @generated from message code.user.v1.GetUserResponse
 */
export class GetUserResponse extends Message<GetUserResponse> {
  /**
   * @generated from field: code.user.v1.GetUserResponse.Result result = 1;
   */
  result = GetUserResponse_Result.OK;

  /**
   * The user associated with the identifier
   *
   * @generated from field: code.user.v1.User user = 2;
   */
  user?: User;

  /**
   * The data container where the user can store a copy of their data
   *
   * @generated from field: code.common.v1.DataContainerId data_container_id = 3;
   */
  dataContainerId?: DataContainerId;

  /**
   * Metadata about the user based for the instance of their view
   *
   * @generated from oneof code.user.v1.GetUserResponse.metadata
   */
  metadata: {
    /**
     * Metadata that corresponds to a phone-based identifying feature.
     *
     * @generated from field: code.user.v1.PhoneMetadata phone = 5;
     */
    value: PhoneMetadata;
    case: "phone";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Whether client internal flags are enabled for this user
   *
   * @generated from field: bool enable_internal_flags = 6;
   */
  enableInternalFlags = false;

  /**
   * Set of which airdrops the user is eligible to receive
   *
   * @generated from field: repeated code.transaction.v2.AirdropType eligible_airdrops = 7;
   */
  eligibleAirdrops: AirdropType[] = [];

  constructor(data?: PartialMessage<GetUserResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.GetUserResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetUserResponse_Result) },
    { no: 2, name: "user", kind: "message", T: User },
    { no: 3, name: "data_container_id", kind: "message", T: DataContainerId },
    { no: 5, name: "phone", kind: "message", T: PhoneMetadata, oneof: "metadata" },
    { no: 6, name: "enable_internal_flags", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "eligible_airdrops", kind: "enum", T: proto3.getEnumType(AirdropType), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUserResponse {
    return new GetUserResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUserResponse {
    return new GetUserResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUserResponse {
    return new GetUserResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetUserResponse | PlainMessage<GetUserResponse> | undefined, b: GetUserResponse | PlainMessage<GetUserResponse> | undefined): boolean {
    return proto3.util.equals(GetUserResponse, a, b);
  }
}

/**
 * @generated from enum code.user.v1.GetUserResponse.Result
 */
export enum GetUserResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The user doesn't exist
   *
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,

  /**
   * The user is no longer invited
   *
   * @generated from enum value: NOT_INVITED = 2;
   */
  NOT_INVITED = 2,

  /**
   * The user exists, but at least one of their timelock accounts is unlocked
   *
   * @generated from enum value: UNLOCKED_TIMELOCK_ACCOUNT = 3;
   */
  UNLOCKED_TIMELOCK_ACCOUNT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(GetUserResponse_Result)
proto3.util.setEnumType(GetUserResponse_Result, "code.user.v1.GetUserResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
  { no: 2, name: "NOT_INVITED" },
  { no: 3, name: "UNLOCKED_TIMELOCK_ACCOUNT" },
]);

/**
 * @generated from message code.user.v1.UpdatePreferencesRequest
 */
export class UpdatePreferencesRequest extends Message<UpdatePreferencesRequest> {
  /**
   * The public key of the owner account that signed this request message.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The data container for the copy of the contact list being added to.
   *
   * @generated from field: code.common.v1.DataContainerId container_id = 2;
   */
  containerId?: DataContainerId;

  /**
   * The signature is of serialize(UpdatePreferencesRequest) without this field set
   * using the private key of owner_account_id.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  /**
   * The user's locale, which is used for server-side localization of things like
   * chat messages, pushes, etc. If no locale is set, or the provided locale isn't
   * supported, then English is used as the default fallback.
   *
   * Note: This is required since it's the only preference. In the future, we'll add
   *       optional fields, where the subset of fields provided will be the ones that
   *       are updated.
   *
   * @generated from field: code.common.v1.Locale locale = 4;
   */
  locale?: Locale;

  constructor(data?: PartialMessage<UpdatePreferencesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.UpdatePreferencesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "container_id", kind: "message", T: DataContainerId },
    { no: 3, name: "signature", kind: "message", T: Signature },
    { no: 4, name: "locale", kind: "message", T: Locale },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdatePreferencesRequest {
    return new UpdatePreferencesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdatePreferencesRequest {
    return new UpdatePreferencesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdatePreferencesRequest {
    return new UpdatePreferencesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdatePreferencesRequest | PlainMessage<UpdatePreferencesRequest> | undefined, b: UpdatePreferencesRequest | PlainMessage<UpdatePreferencesRequest> | undefined): boolean {
    return proto3.util.equals(UpdatePreferencesRequest, a, b);
  }
}

/**
 * @generated from message code.user.v1.UpdatePreferencesResponse
 */
export class UpdatePreferencesResponse extends Message<UpdatePreferencesResponse> {
  /**
   * @generated from field: code.user.v1.UpdatePreferencesResponse.Result result = 1;
   */
  result = UpdatePreferencesResponse_Result.OK;

  constructor(data?: PartialMessage<UpdatePreferencesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.UpdatePreferencesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(UpdatePreferencesResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdatePreferencesResponse {
    return new UpdatePreferencesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdatePreferencesResponse {
    return new UpdatePreferencesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdatePreferencesResponse {
    return new UpdatePreferencesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdatePreferencesResponse | PlainMessage<UpdatePreferencesResponse> | undefined, b: UpdatePreferencesResponse | PlainMessage<UpdatePreferencesResponse> | undefined): boolean {
    return proto3.util.equals(UpdatePreferencesResponse, a, b);
  }
}

/**
 * @generated from enum code.user.v1.UpdatePreferencesResponse.Result
 */
export enum UpdatePreferencesResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The provided locale couldn't be parsed or recognized and is invalid.
   *
   * @generated from enum value: INVALID_LOCALE = 1;
   */
  INVALID_LOCALE = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(UpdatePreferencesResponse_Result)
proto3.util.setEnumType(UpdatePreferencesResponse_Result, "code.user.v1.UpdatePreferencesResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "INVALID_LOCALE" },
]);

/**
 * @generated from message code.user.v1.LoginToThirdPartyAppRequest
 */
export class LoginToThirdPartyAppRequest extends Message<LoginToThirdPartyAppRequest> {
  /**
   * The intent ID identifying the instance of the login flow.
   *
   * @generated from field: code.common.v1.IntentId intent_id = 1;
   */
  intentId?: IntentId;

  /**
   * The relationship authority account logging in.
   *
   * @generated from field: code.common.v1.SolanaAccountId user_id = 2;
   */
  userId?: SolanaAccountId;

  /**
   * Signature of this message using the user private key, which authenticates
   * the user.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<LoginToThirdPartyAppRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.LoginToThirdPartyAppRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "intent_id", kind: "message", T: IntentId },
    { no: 2, name: "user_id", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginToThirdPartyAppRequest {
    return new LoginToThirdPartyAppRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginToThirdPartyAppRequest {
    return new LoginToThirdPartyAppRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginToThirdPartyAppRequest {
    return new LoginToThirdPartyAppRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LoginToThirdPartyAppRequest | PlainMessage<LoginToThirdPartyAppRequest> | undefined, b: LoginToThirdPartyAppRequest | PlainMessage<LoginToThirdPartyAppRequest> | undefined): boolean {
    return proto3.util.equals(LoginToThirdPartyAppRequest, a, b);
  }
}

/**
 * @generated from message code.user.v1.LoginToThirdPartyAppResponse
 */
export class LoginToThirdPartyAppResponse extends Message<LoginToThirdPartyAppResponse> {
  /**
   * @generated from field: code.user.v1.LoginToThirdPartyAppResponse.Result result = 1;
   */
  result = LoginToThirdPartyAppResponse_Result.OK;

  constructor(data?: PartialMessage<LoginToThirdPartyAppResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.LoginToThirdPartyAppResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(LoginToThirdPartyAppResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginToThirdPartyAppResponse {
    return new LoginToThirdPartyAppResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginToThirdPartyAppResponse {
    return new LoginToThirdPartyAppResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginToThirdPartyAppResponse {
    return new LoginToThirdPartyAppResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LoginToThirdPartyAppResponse | PlainMessage<LoginToThirdPartyAppResponse> | undefined, b: LoginToThirdPartyAppResponse | PlainMessage<LoginToThirdPartyAppResponse> | undefined): boolean {
    return proto3.util.equals(LoginToThirdPartyAppResponse, a, b);
  }
}

/**
 * @generated from enum code.user.v1.LoginToThirdPartyAppResponse.Result
 */
export enum LoginToThirdPartyAppResponse_Result {
  /**
   * This supports idempotency. The same login with the same user will result
   * in OK.
   *
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * There is no request for the provided intent ID.
   *
   * @generated from enum value: REQUEST_NOT_FOUND = 1;
   */
  REQUEST_NOT_FOUND = 1,

  /**
   * The request requires a payment. Call SubmitIntent instead.
   *
   * @generated from enum value: PAYMENT_REQUIRED = 2;
   */
  PAYMENT_REQUIRED = 2,

  /**
   * The request exists, but doesn't support login.
   *
   * @generated from enum value: LOGIN_NOT_SUPPORTED = 3;
   */
  LOGIN_NOT_SUPPORTED = 3,

  /**
   * A login with a different user already exists
   *
   * @generated from enum value: DIFFERENT_LOGIN_EXISTS = 4;
   */
  DIFFERENT_LOGIN_EXISTS = 4,

  /**
   * The provided account is not valid for login. It must be a relationship
   * account with the correct identifier specified in the original request.
   *
   * @generated from enum value: INVALID_ACCOUNT = 5;
   */
  INVALID_ACCOUNT = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(LoginToThirdPartyAppResponse_Result)
proto3.util.setEnumType(LoginToThirdPartyAppResponse_Result, "code.user.v1.LoginToThirdPartyAppResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "REQUEST_NOT_FOUND" },
  { no: 2, name: "PAYMENT_REQUIRED" },
  { no: 3, name: "LOGIN_NOT_SUPPORTED" },
  { no: 4, name: "DIFFERENT_LOGIN_EXISTS" },
  { no: 5, name: "INVALID_ACCOUNT" },
]);

/**
 * @generated from message code.user.v1.GetLoginForThirdPartyAppRequest
 */
export class GetLoginForThirdPartyAppRequest extends Message<GetLoginForThirdPartyAppRequest> {
  /**
   * The intent ID identifying the instance of the login flow.
   *
   * @generated from field: code.common.v1.IntentId intent_id = 1;
   */
  intentId?: IntentId;

  /**
   * Owner account owned by the third party used in domain verification.
   *
   * @generated from field: code.common.v1.SolanaAccountId verifier = 2;
   */
  verifier?: SolanaAccountId;

  /**
   * Signature of this message using the verifier private key, which in addition
   * to domain verification, authenticates the third party.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetLoginForThirdPartyAppRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.GetLoginForThirdPartyAppRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "intent_id", kind: "message", T: IntentId },
    { no: 2, name: "verifier", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLoginForThirdPartyAppRequest {
    return new GetLoginForThirdPartyAppRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLoginForThirdPartyAppRequest {
    return new GetLoginForThirdPartyAppRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLoginForThirdPartyAppRequest {
    return new GetLoginForThirdPartyAppRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLoginForThirdPartyAppRequest | PlainMessage<GetLoginForThirdPartyAppRequest> | undefined, b: GetLoginForThirdPartyAppRequest | PlainMessage<GetLoginForThirdPartyAppRequest> | undefined): boolean {
    return proto3.util.equals(GetLoginForThirdPartyAppRequest, a, b);
  }
}

/**
 * @generated from message code.user.v1.GetLoginForThirdPartyAppResponse
 */
export class GetLoginForThirdPartyAppResponse extends Message<GetLoginForThirdPartyAppResponse> {
  /**
   * @generated from field: code.user.v1.GetLoginForThirdPartyAppResponse.Result result = 1;
   */
  result = GetLoginForThirdPartyAppResponse_Result.OK;

  /**
   * The relationship authority account that logged in.
   *
   * @generated from field: code.common.v1.SolanaAccountId user_id = 2;
   */
  userId?: SolanaAccountId;

  constructor(data?: PartialMessage<GetLoginForThirdPartyAppResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.GetLoginForThirdPartyAppResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetLoginForThirdPartyAppResponse_Result) },
    { no: 2, name: "user_id", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLoginForThirdPartyAppResponse {
    return new GetLoginForThirdPartyAppResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLoginForThirdPartyAppResponse {
    return new GetLoginForThirdPartyAppResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLoginForThirdPartyAppResponse {
    return new GetLoginForThirdPartyAppResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetLoginForThirdPartyAppResponse | PlainMessage<GetLoginForThirdPartyAppResponse> | undefined, b: GetLoginForThirdPartyAppResponse | PlainMessage<GetLoginForThirdPartyAppResponse> | undefined): boolean {
    return proto3.util.equals(GetLoginForThirdPartyAppResponse, a, b);
  }
}

/**
 * @generated from enum code.user.v1.GetLoginForThirdPartyAppResponse.Result
 */
export enum GetLoginForThirdPartyAppResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * There is no request for the provided intent ID.
   *
   * @generated from enum value: REQUEST_NOT_FOUND = 1;
   */
  REQUEST_NOT_FOUND = 1,

  /**
   * The request exists, but doesn't support login.
   *
   * @generated from enum value: LOGIN_NOT_SUPPORTED = 2;
   */
  LOGIN_NOT_SUPPORTED = 2,

  /**
   * The intent supports login, but it hasn't been submitted. There is no
   * logged in user yet.
   *
   * @generated from enum value: NO_USER_LOGGED_IN = 3;
   */
  NO_USER_LOGGED_IN = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(GetLoginForThirdPartyAppResponse_Result)
proto3.util.setEnumType(GetLoginForThirdPartyAppResponse_Result, "code.user.v1.GetLoginForThirdPartyAppResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "REQUEST_NOT_FOUND" },
  { no: 2, name: "LOGIN_NOT_SUPPORTED" },
  { no: 3, name: "NO_USER_LOGGED_IN" },
]);

/**
 * User is the highest order of a form of identity within Code.
 *
 * Note: Users outside Code are modelled as relationship accounts
 *
 * @generated from message code.user.v1.User
 */
export class User extends Message<User> {
  /**
   * The user's ID
   *
   * @generated from field: code.common.v1.UserId id = 1;
   */
  id?: UserId;

  /**
   * The identifying features that are associated with the user
   *
   * @generated from field: code.user.v1.View view = 2;
   */
  view?: View;

  constructor(data?: PartialMessage<User>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.User";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: UserId },
    { no: 2, name: "view", kind: "message", T: View },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): User {
    return new User().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): User {
    return new User().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): User {
    return new User().fromJsonString(jsonString, options);
  }

  static equals(a: User | PlainMessage<User> | undefined, b: User | PlainMessage<User> | undefined): boolean {
    return proto3.util.equals(User, a, b);
  }
}

/**
 * View is a well-defined set of identifying features. It is contrained to having
 * exactly one feature set at a time, for now.
 *
 * @generated from message code.user.v1.View
 */
export class View extends Message<View> {
  /**
   * The phone number associated with a user.
   *
   * Note: This field is mandatory as of right now, since it's the only one
   *       supported to date.
   *
   * @generated from field: code.common.v1.PhoneNumber phone_number = 1;
   */
  phoneNumber?: PhoneNumber;

  constructor(data?: PartialMessage<View>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.View";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phone_number", kind: "message", T: PhoneNumber },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): View {
    return new View().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): View {
    return new View().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): View {
    return new View().fromJsonString(jsonString, options);
  }

  static equals(a: View | PlainMessage<View> | undefined, b: View | PlainMessage<View> | undefined): boolean {
    return proto3.util.equals(View, a, b);
  }
}

/**
 * @generated from message code.user.v1.PhoneMetadata
 */
export class PhoneMetadata extends Message<PhoneMetadata> {
  /**
   * State that determines whether a phone number is linked to the owner
   * account. A phone number is linked if we can treat it as an alias.
   * This is notably different from association, which answers the question
   * of whether the number was linked at any point in time.
   *
   * @generated from field: bool is_linked = 1;
   */
  isLinked = false;

  constructor(data?: PartialMessage<PhoneMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.user.v1.PhoneMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_linked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PhoneMetadata {
    return new PhoneMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PhoneMetadata {
    return new PhoneMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PhoneMetadata {
    return new PhoneMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PhoneMetadata | PlainMessage<PhoneMetadata> | undefined, b: PhoneMetadata | PlainMessage<PhoneMetadata> | undefined): boolean {
    return proto3.util.equals(PhoneMetadata, a, b);
  }
}

